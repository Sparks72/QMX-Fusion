<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRP-Labs QMX Communications Interface</title>
<!--Uncomment this next line if you don't have the sortable.min.js script in the same directory as the Interface file. -->  
  <!-- <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script> -->
<!--Put this next line in comments if have not downloaded it. -->   
   <script src="Sortable.min.js"></script>
	
	<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
            user-select: none;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .main-panel {
            display: grid;
            grid-template-columns: 1fr 400px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .left-panel, .right-panel, .center-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .panel h3 {
            cursor: grab;
        }

        .panel h3:active {
            cursor: grabbing;
        }

        .sortable-ghost {
            opacity: 0.4;
            background: #00ff88;
        }

        .sortable-drag {
            opacity: 0.9;
            transform: rotate(2deg);
        }


        .frequency-display.lcd-panel {
            background: #000;
            border-radius: 10px;
            padding: 15px 20px;
            text-align: left;
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .lcd-row {
            font-family: 'Courier New', monospace;
            font-size: 1.8em;
            color: #00ff88;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
            letter-spacing: 0.05em;
            white-space: pre;
            line-height: 1.2;
        }

        .tuning-knob-container {
            width: 250px;
            height: 250px;
            position: relative;
            margin: 20px auto;
            display: flex !important;
            justify-content: center;
            align-items: center;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .tuning-knob-container:active {
            cursor: grabbing;
        }

        .tuning-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 2px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.15) 0deg, rgba(0, 0, 0, 0.1) 5deg, rgba(255, 255, 255, 0.15) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 2%, #c0c0c0 4%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 30% 30%, 100% 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 15%, rgba(0, 0, 0, 0.05) 15.5%, transparent 16%);
            z-index: 1;
        }

        .tuning-knob::after {
            content: "";
            position: absolute;
            width: 8px !important;
            height: 100px;
            background-color: #333 !important;
            border-radius: 8px;
            top: 10px;
            z-index: 3;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tuning-knob-center {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob:hover::after {
            background-color: #00ff88 !important;
        }

        .frequency-markings {
            position: absolute;
            width: 280px;
            height: 280px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0;
        }

        .frequency-mark {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            transform-origin: center;
        }

        .frequency-mark.major {
            width: 3px;
            height: 20px;
            background: rgba(0, 255, 136, 0.8);
        }

        .frequency-mark.minor {
            width: 1px;
            height: 10px;
            background: rgba(255, 255, 255, 0.4);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9em;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .btn-secondary:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            color: #fff;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 71, 87, 0.4);
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .mode-btn {
            padding: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        select {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        select:disabled {
            background: rgba(100, 100, 100, 0.2);
            color: #888;
            border-color: rgba(100, 100, 100, 0.3);
            cursor: not-allowed;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .meter {
            height: 80px;
            background: #111;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .meter-scale {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.8em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }

        .meter-bar {
            height: 20px;
            background: #222;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            border: 1px solid #333;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .meter-indicator {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 30%;
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        #sMeter {
            background: linear-gradient(90deg, 
                #00ff88 0%,
                #00ff88 50%, 
                #ffff00 70%,
                #ff9500 85%,
                #ff4757 100%);
        }

        #sMeter::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.9),
                        0 0 15px rgba(0, 255, 136, 0.5);
        }

        #swrMeter {
            background: linear-gradient(90deg, 
                #00ff88 0%,
                #00ff88 30%, 
                #ffff00 50%,
                #ff9500 70%,
                #ff4757 100%);
        }

        #swrMeter::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.9),
                        0 0 15px rgba(255, 71, 87, 0.5);
        }

        .meter-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 19.9%,
                rgba(255, 255, 255, 0.1) 20%,
                rgba(255, 255, 255, 0.1) 20.1%
            );
            pointer-events: none;
        }
    
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-text {
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .status-text.connected {
            color: #00ff88;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
        }

        .status-text.disconnected {
            color: #ff4757;
            text-shadow: 0 0 8px rgba(255, 71, 87, 0.6);
            text-transform: uppercase;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #00ff88;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .memory-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .memory-btn {
            padding: 8px 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 45px;
            position: relative;
        }

        .memory-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .memory-btn.memory-occupied {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.5);
            color: #00ff88;
        }

        .memory-btn.memory-selected {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .memory-btn.memory-occupied:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        .memory-btn.memory-store-warning {
            background: rgba(255, 71, 87, 0.2);
            border-color: rgba(255, 71, 87, 0.5);
        }

        .memory-btn.memory-store-warning:hover {
            background: rgba(255, 71, 87, 0.3);
        }

        .memory-edit-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 25px;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            min-width: 400px;
            max-width: 500px;
        }

        .memory-edit-modal.active {
            display: block;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
        }

        .modal-overlay.active {
            display: block;
        }

        .memory-edit-modal h3 {
            margin-bottom: 15px;
            color: #00ff88;
        }

        .memory-edit-modal input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
        }

        .memory-edit-modal .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .memory-label {
            font-size: 0.7em;
            display: block;
            margin-top: 2px;
            color: #00ff88;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .band-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .band-btn {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: bold;
        }

        .band-btn.active {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            border-color: #00ff88;
        }

        .band-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        .cat-log {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .cat-log-entry {
            margin-bottom: 2px;
            opacity: 0.8;
        }

        .cat-log-entry.tx {
            color: #00ff88;
        }

        .cat-log-entry.rx {
            color: #00ccff;
        }

        .cat-log-entry.error {
            color: #ff4757;
        }

        .volume-knob-container {
            width: 80px;
            height: 80px;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .volume-knob-container:active {
            cursor: grabbing;
        }

        .knobs-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 10px;
        }

        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .knob-group label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .knob-level {
            font-family: "Courier New", monospace;
            font-size: 0.9rem;
            text-align: center;
            color: #fff;
            margin-top: 2px;
        }

        .volume-knob-container,
        .volume-knob {
            display: flex !important;
            justify-content: center;
            align-items: center;
            visibility: visible !important;
        }

        .volume-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 1px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.1) 0deg, rgba(0, 0, 0, 0.07) 5deg, rgba(255, 255, 255, 0.1) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 1%, #c0c0c0 2%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 20% 20%, 100% 100%;
        }

        .volume-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 10%, rgba(0, 0, 0, 0.03) 10.5%, transparent 11%);
            z-index: 1;
        }

        .volume-knob::after {
            content: "";
            position: absolute;
            width: 5px !important;
            height: 38px;
            background-color: #333 !important;
            border-radius: 5px;
            top: 5px;
            z-index: 3;
            transition: background-color 0.2s ease;
        }

        .volume-knob-center {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
        }

        .volume-knob:hover::after {
            background-color: #00ff88 !important;
        }

        .volume-knob::before,
        .volume-knob::after,
        .volume-knob-center {
            pointer-events: none;
        }

        .tuning-knob::before,
        .tuning-knob::after,
        .tuning-knob-center {
            pointer-events: none;
        }
		
        /* QSO Logger Styles */
        #qsoLoggerPanel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .qso-inputs-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 15px;
        }
        .qso-inputs-grid input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.2);
            color: #fff;
            font-size: 0.9em;
        }
        .qth-group, .comments-group {
            grid-column: 1 / -1;
        }
        .qso-info-bar {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #00ff88;
        }
        .qso-actions {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 10px;
        }
        .btn-log-qso {
            background: linear-gradient(45deg, #00ffc8, #0099ff);
            color: #000;
            font-weight: bold;
        }
        .btn-log-qso:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 200, 0.4);
        }
        .log-management {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .log-management input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.2);
            color: #fff;
            font-size: 0.9em;
        }
        .log-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .qso-log-table {
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }
        .log-header, .log-row {
            display: grid;
            grid-template-columns: 1.2fr 1fr 1fr 0.8fr 0.8fr;
            gap: 10px;
            padding: 8px 10px;
            align-items: center;
        }
        .log-header {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            font-weight: bold;
            font-size: 0.85em;
            text-transform: uppercase;
        }
        .log-body {
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            flex-grow: 1;
        }
        .log-row {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .log-row:last-child {
            border-bottom: none;
        }
        .log-row div {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .log-empty-msg {
            color: #888;
            text-align: center;
            padding: 20px;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 768px) {
            .volume-knob-container {
                width: 60px;
                height: 60px;
            }
            .knobs-row {
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>QRP-Labs QMX+</h1>
            <p>Professional QRP Communications Interface</p>
        </div>

        <div class="main-panel">
            <div class="left-panel">
                <div class="panel" id="serialPanel">
                    <h3>Serial Connection</h3>
                    <div class="control-group">
                        <label>Baud Rate</label>
                        <select id="baudRate">
                            <option value="9600">9600</option>
                            <option value="19200">19200</option>
                            <option value="38400">38400</option>
                            <option value="57600">57600</option>
                            <option value="115200" selected>115200</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button id="connectBtn" class="btn btn-primary">Connect Serial</button>
                    </div>
                </div>

               <div class="panel" id="modePanel">
                <h3>Operating Mode</h3>
                <div class="mode-buttons">
                    <div class="mode-btn active" data-mode="USB" data-catmode="2">USB</div>
                    <div class="mode-btn" data-mode="LSB" data-catmode="1">LSB</div>
                    <div class="mode-btn" data-mode="CW" data-catmode="3">CW</div>
                    <div class="mode-btn" data-mode="DIGI" data-catmode="6">DIGI</div>
                </div>
            </div>
                <div class="panel" id="stepPanel">
                    <h3>Tuning Step</h3>
                    <div class="control-group">
                        <label>Step Size</label>
                        <select id="stepSize">
                            <option value="1">1 Hz</option>
                            <option value="10">10 Hz</option>
                            <option value="100"selected>100 Hz</option>
                            <option value="1000">1 kHz</option>
                            <option value="10000">10 kHz</option>
                        </select>
                    </div>
                </div>

                <div class="panel" id="bandPanel">
                    <h3>Band</h3>
                    <div class="band-buttons">
                        <div class="band-btn" data-band="160">160m</div>
                        <div class="band-btn" data-band="80">80m</div>
                        <div class="band-btn" data-band="40">40m</div>
                        <div class="band-btn" data-band="30">30m</div>
                        <div class="band-btn active" data-band="20">20m</div>
                        <div class="band-btn" data-band="17">17m</div>
                        <div class="band-btn" data-band="15">15m</div>
                        <div class="band-btn" data-band="12">12m</div>
                        <div class="band-btn" data-band="10">10m</div>
                        <div class="band-btn" data-band="6">6m</div>
                    </div>
                </div>

                <div class="panel" id="catPanel">
                    <h3>CAT Monitor</h3>
                    <div class="cat-log" id="catLog"></div>
                </div>
            </div>

            <div class="center-panel">
                <div class="panel frequency-display lcd-panel" id="lcdPanel">
                    <div id="lcdRow1" class="lcd-row">QMX Interface...</div>
                    <div id="lcdRow2" class="lcd-row">Connect Radio</div>
                </div>

                <div class="panel" id="tuningPanel">
                    <h3 style="text-align: center; margin-bottom: 15px;">Main Tuning</h3>
                    <div class="tuning-knob-container" id="tuningKnobContainer">
                        <div class="frequency-markings" id="frequencyMarkings"></div>
                        <div class="tuning-knob" id="tuningKnob" tabindex="0" role="slider" aria-label="Frequency Tuning" aria-valuemin="100000" aria-valuemax="999999999" aria-valuenow="14205000">
                            <div class="tuning-knob-center"></div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="vfoPanel">
                    <h3>VFO</h3>
                    <div class="controls-grid">
                        <button class="btn btn-primary" id="vfoA">VFO A</button>
                        <button class="btn btn-secondary" id="vfoB">VFO B</button>
                        <button class="btn btn-secondary" id="vfoSwap">A↔B</button>
                        <button class="btn btn-secondary" id="vfoCopy">A→B</button>
                    </div>
                </div>

                <div class="panel" id="transmitPanel">
                    <h3>Transmit</h3>
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="txBtn">TX</button>
                        <button class="btn btn-primary" id="rxBtn">RX</button>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="panel" id="qsoLoggerPanel">
                    <h3>QSO Logger (<span id="qsoCount">0</span> QSOs)</h3>
                    <div class="qso-inputs-grid">
                        <div class="control-group">
                            <label for="qsoCallsign">CALLSIGN</label>
                            <input type="text" id="qsoCallsign" placeholder="W1AW">
                        </div>
                        <div class="control-group">
                            <label for="qsoRstSent">RST SENT</label>
                            <input type="text" id="qsoRstSent" value="599">
                        </div>
                        <div class="control-group">
                            <label for="qsoRstRcvd">RST RCVD</label>
                            <input type="text" id="qsoRstRcvd" value="599">
                        </div>
                        <div class="control-group">
                            <label for="qsoName">NAME</label>
                            <input type="text" id="qsoName" placeholder="John">
                        </div>
                        <div class="control-group qth-group">
                            <label for="qsoQth">QTH</label>
                            <input type="text" id="qsoQth" placeholder="City, State">
                        </div>
                        <div class="control-group comments-group">
                            <label for="qsoComments">COMMENTS</label>
                            <input type="text" id="qsoComments" placeholder="Nice signal">
                        </div>
                    </div>
                    <div class="qso-info-bar" id="qsoInfoBar">
                        <span>14.205 MHz</span> &bull; <span>USB</span> &bull; <span>20m</span>
                        <span style="float: right;">2025-01-20 14:35 UTC</span>
                    </div>
                    <div class="qso-actions">
                        <button class="btn btn-log-qso" id="logQsoBtn">LOG QSO</button>
                        <button class="btn btn-secondary" id="clearQsoInputsBtn">CLEAR</button>
                    </div>
                    <div class="log-management">
                        <input type="text" id="qsoSearch" placeholder="Search callsigns...">
                        <div class="log-buttons">
                            <button class="btn btn-secondary" id="exportAdifBtn">EXPORT ADIF</button>
                            <button class="btn btn-secondary" id="importAdifBtn">IMPORT ADIF</button>
                            <button class="btn btn-danger" id="clearLogBtn">CLEAR LOG</button>
                            <input type="file" id="importAdifFile" accept=".adi,.adif" style="display: none;">
                        </div>
                    </div>
                    <div class="qso-log-table">
                        <div class="log-header">
                            <div>TIME</div>
                            <div>CALL</div>
                            <div>FREQ</div>
                            <div>MODE</div>
                            <div>RST</div>
                        </div>
                        <div class="log-body" id="qsoLogBody">
                            <div class="log-empty-msg">No QSOs logged yet</div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="controlsPanel">
                    <h3>Controls</h3>
                    <div class="knobs-row">
                        <div class="knob-group">
                            <label>AF Gain</label>
                            <div class="volume-knob-container">
                                <div class="volume-knob" id="volumeKnob" tabindex="0" role="slider" aria-label="Volume Control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="75">
                                    <div class="volume-knob-center"></div>
                                </div>
                            </div>
                            <div class="knob-level" id="volumeLevel">75%</div>
                        </div>
                        <div class="knob-group">
                            <label>Keyer </label>
                            <div class="volume-knob-container">
                                <div class="volume-knob" id="rfGainKnob" tabindex="0" role="slider" aria-label="Keyer" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
                                    <div class="volume-knob-center"></div>
                                </div>
                            </div>
                            <div class="knob-level" id="rfGainLevel">100%</div>
                        </div>
                        <div class="knob-group">
                            <label>Dummy</label>
                            <div class="volume-knob-container">
                                <div class="volume-knob" id="powerKnob" tabindex="0" role="slider" aria-label="Power Control" aria-valuemin="0" aria-valuemax="50" aria-valuenow="50">
                                    <div class="volume-knob-center"></div>
                                </div>
                            </div>
                            <div class="knob-level" id="powerLevel">5.0W</div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="memoryPanel">
                    <h3>Memory</h3>
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="storeBtn">Store</button>
                        <button class="btn btn-secondary" id="recallBtn">Recall</button>
                        <button class="btn btn-secondary" id="editBtn">Edit</button>
                        <button class="btn btn-secondary" id="clearBtn">Clear</button>
                    </div>
                    <div class="memory-buttons">
                        <div class="memory-btn" data-channel="1">M1</div>
                        <div class="memory-btn" data-channel="2">M2</div>
                        <div class="memory-btn" data-channel="3">M3</div>
                        <div class="memory-btn" data-channel="4">M4</div>
                        <div class="memory-btn" data-channel="5">M5</div>
                        <div class="memory-btn" data-channel="6">M6</div>
                        <div class="memory-btn" data-channel="7">M7</div>
                        <div class="memory-btn" data-channel="8">M8</div>
                        <div class="memory-btn" data-channel="9">M9</div>
                        <div class="memory-btn" data-channel="10">M10</div>
                    </div>
                    <div class="controls-grid" style="margin-top: 10px;">
                        <button class="btn btn-secondary" id="exportBtn">Export</button>
                        <button class="btn btn-secondary" id="importBtn">Import</button>
                        <button class="btn btn-secondary" id="clearAllBtn" style="grid-column: span 2;">Clear All</button>
                    </div>
                    <input type="file" id="importFile" accept=".json" style="display: none;">
                </div>

                <div class="panel" id="sMeterPanel">
                    <h3 style="color: #00ff88; text-shadow: 0 0 5px rgba(0, 255, 136, 0.5);">Signal Strength</h3>
                    <div class="meter">
                        <div class="meter-scale">
                            <span>S1</span>
                            <span>S3</span>
                            <span>S5</span>
                            <span>S7</span>
                            <span>S9</span>
                            <span style="color: #ff9500;">+20</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-indicator" id="sMeter"></div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="swrPanel">
                    <h3 style="color: #ff9500; text-shadow: 0 0 5px rgba(255, 149, 0, 0.5);">SWR</h3>
                    <div class="meter">
                        <div class="meter-scale">
                            <span style="color: #00ff88;">1:1</span>
                            <span style="color: #00ff88;">1.5</span>
                            <span style="color: #ffff00;">2:1</span>
                            <span style="color: #ff9500;">3:1</span>
                            <span style="color: #ff4757;">5:1</span>
                            <span style="color: #ff4757;">∞</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-indicator" id="swrMeter"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span class="status-text disconnected" id="statusText">DISCONNECTED</span>
            </div>
            <div>QMX CAT Interface</div>
            <div id="currentTime"></div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="memory-edit-modal" id="memoryEditModal">
        <h3>Edit Memory Channel <span id="editChannelNumber"></span></h3>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Frequency (MHz)</label>
            <input type="text" id="memoryFreqInput" placeholder="14.205" style="margin-bottom: 5px;">
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Mode</label>
            <select id="memoryModeSelect" style="width: 100%; padding: 10px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px;">
                <option value="USB">USB</option>
                <option value="LSB">LSB</option>
                <option value="CW">CW</option>
                <option value="DIGI">DIGI</option>
            </select>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Band</label>
            <select id="memoryBandSelect" style="width: 100%; padding: 10px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px;">
                <option value="160">160m</option>
                <option value="80">80m</option>
                <option value="40">40m</option>
                <option value="30">30m</option>
                <option value="20">20m</option>
                <option value="17">17m</option>
                <option value="15">15m</option>
                <option value="12">12m</option>
                <option value="10">10m</option>
                <option value="6">6m</option>
            </select>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Label/Description</label>
            <input type="text" id="memoryLabelInput" placeholder="Enter label (e.g., Local Repeater)">
        </div>
        
        <div class="btn-group">
            <button class="btn btn-primary" id="saveMemoryEdit">Save</button>
            <button class="btn btn-secondary" id="cancelMemoryEdit">Cancel</button>
        </div>
    </div>

    <script>
        class QMXInterface {
            constructor() {
                this.frequency = 14205000;
                this.stepSize = 100;
                this.mode = 'USB';
                this.connected = false;
                this.band = '20';
                this.currentVFO = 'A';
                this.transmitting = false;
				this.pollingInterval = null;
                
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.commandQueue = [];
                this.isProcessingQueue = false;
                this.catTimeout = null;
                this.connectionCheckTimeout = null;
                this.lastCommandTime = 0;
                
                this.memoryChannels = new Array(10).fill(null);
                this.selectedMemoryChannel = null;
                this.memoryMode = 'recall';
                
                this.catLogElement = null;
                
                this.tuningKnobRotation = 0;
                this.tuningLastAngle = 0;
                this.isTuningAdjusting = false;
                this.tuningAnimationFrame = null;
                
                this.totalRotationRange = 270;
                this.minRotation = -135;
                this.maxRotation = 135;
                this.volumeKnobRotation = 0;
                this.volumeLevel = 75;
                this.volumeLastAngle = 0;
                this.isVolumeAdjusting = false;
                this.volumeAnimationFrame = null;
                this.volumeTimeout = null;
                
                this.rfGainKnobRotation = 0;
                this.rfGainLevel = 22;
                this.rfGainLastAngle = 0;
                this.isRFGainAdjusting = false;
                this.rfGainAnimationFrame = null;
                this.rfGainTimeout = null;
                
                this.powerKnobRotation = 0;
                this.powerLevel = 50;
                this.powerLastAngle = 0;
                this.isPowerAdjusting = false;
                this.powerAnimationFrame = null;
                this.powerTimeout = null;
                this.powerLevelBeforeAdjust = 50;

                this.qsoLog = [];
                this.qsoLogFilter = '';
                
                // NEW: Property to hold last-tuned frequencies per band
                this.lastFrequencies = {
                    '160': 1900000, '80': 3500000, '40': 7000000, '30': 10140000, '20': 14205000,
                    '17': 18068000, '15': 21000000, '12': 24890000, '10': 28000000, '6': 50000000
                };
                // NEW: Property for debouncing frequency saves
                this.saveFreqTimeout = null;

                try {
                    this.catLogElement = document.getElementById('catLog');
                    
                    this.loadLayout();
                    this.loadLastFrequencies(); // NEW: Call new method to load frequencies
                    this.frequency = this.lastFrequencies[this.band]; // NEW: Set initial frequency from saved state

                    this.initDraggablePanels();
                    this.initTuningKnob();
                    this.initEventListeners();
                    this.initVolumeControl();
                    this.initRFGainControl();
                    this.initPowerControl();
                    this.initMemorySystem();
                    this.initQsoLogger();
                    this.updateDisplay();
                    this.updateTXStatus();
                    this.updateConnectionStatus();
                    this.initTimeSync();
                    
                    window.addEventListener('blur', () => {
                        if (this.isPowerAdjusting) this.stopPowerAdjust();
                        if (this.isVolumeAdjusting) this.stopVolumeAdjust();
                        if (this.isRFGainAdjusting) this.stopRFGainAdjust();
                        if (this.isTuningAdjusting) this.stopTuningAdjust();
                    });
                } catch (error) {
                    console.error('Failed to initialize QMX Interface:', error);
                }
            }

            // --- Frequency & Layout Management ---
            loadLastFrequencies() {
                const savedFrequencies = localStorage.getItem('qmxLastFrequencies');
                if (savedFrequencies) {
                    try {
                        const parsedFrequencies = JSON.parse(savedFrequencies);
                        // Merge saved frequencies with defaults to ensure all bands are covered
                        this.lastFrequencies = { ...this.lastFrequencies, ...parsedFrequencies };
                        console.log('Loaded last-used frequencies.');
                    } catch(e) {
                        console.error('Could not parse saved frequencies, using defaults.');
                    }
                }
            }
            
            saveLastFrequency() {
                if (this.saveFreqTimeout) {
                    clearTimeout(this.saveFreqTimeout);
                }
                this.saveFreqTimeout = setTimeout(() => {
                    this.lastFrequencies[this.band] = this.frequency;
                    localStorage.setItem('qmxLastFrequencies', JSON.stringify(this.lastFrequencies));
                }, 1000); // Save 1 second after tuning stops
            }
            
            initDraggablePanels() {
                try {
                    const leftPanel = document.querySelector('.left-panel');
                    const centerPanel = document.querySelector('.center-panel');
                    const rightPanel = document.querySelector('.right-panel');

                    const options = {
                        group: 'shared-panels',
                        handle: 'h3',
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        dragClass: 'sortable-drag',
                        onEnd: () => {
                            this.saveLayout();
                        }
                    };

                    Sortable.create(leftPanel, options);
                    Sortable.create(centerPanel, options);
                    Sortable.create(rightPanel, options);
                } catch(e) {
                    console.warn("Could not initialize draggable panels. Is Sortable.js loaded?");
                }
            }

            saveLayout() {
                const layout = {
                    left: [...document.querySelectorAll('.left-panel .panel')].map(p => p.id),
                    center: [...document.querySelectorAll('.center-panel .panel')].map(p => p.id),
                    right: [...document.querySelectorAll('.right-panel .panel')].map(p => p.id)
                };
                localStorage.setItem('qmxPanelLayout', JSON.stringify(layout));
                this.logCAT('Panel layout saved.', 'info');
            }

            loadLayout() {
                const savedLayout = localStorage.getItem('qmxPanelLayout');
                if (savedLayout) {
                    try {
                        const layout = JSON.parse(savedLayout);
                        const columns = {
                            left: document.querySelector('.left-panel'),
                            center: document.querySelector('.center-panel'),
                            right: document.querySelector('.right-panel')
                        };

                        Object.keys(layout).forEach(columnKey => {
                            layout[columnKey].forEach(panelId => {
                                const panelElement = document.getElementById(panelId);
                                if (panelElement && columns[columnKey]) {
                                    columns[columnKey].appendChild(panelElement);
                                }
                            });
                        });
                        console.log('Custom panel layout loaded.');
                    } catch (e) {
                        console.error("Failed to load custom layout, using default.", e);
                        localStorage.removeItem('qmxPanelLayout');
                    }
                }
            }
            
            // --- The rest of the methods ---

            // --- QSO Logger ---
            initQsoLogger() {
                try {
                    document.getElementById('logQsoBtn').addEventListener('click', () => this.logQso());
                    document.getElementById('clearQsoInputsBtn').addEventListener('click', () => this.clearQsoInputs());
                    document.getElementById('exportAdifBtn').addEventListener('click', () => this.exportAdif());
                    document.getElementById('importAdifBtn').addEventListener('click', () => document.getElementById('importAdifFile').click());
                    document.getElementById('importAdifFile').addEventListener('change', (e) => this.importAdif(e));
                    document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLog());
                    document.getElementById('qsoSearch').addEventListener('input', (e) => {
                        this.qsoLogFilter = e.target.value;
                        this.renderQsoLog();
                    });
                    document.getElementById('qsoCallsign').addEventListener('keyup', (e) => {
                         e.target.value = e.target.value.toUpperCase();
                         if (e.key === 'Enter') {
                             this.logQso();
                         }
                    });

                    this.loadQsoLog();
                    console.log('QSO Logger initialized');
                } catch (error) {
                    console.error('Failed to initialize QSO Logger:', error);
                }
            }

            updateLoggerInfoBar() {
                try {
                    const infoBar = document.getElementById('qsoInfoBar');
                    if (!infoBar) return;
                    
                    const freqMHz = (this.frequency / 1000000).toFixed(3);
                    const mode = this.mode;
                    const band = this.band + 'm';
                    
                    const syncedUTC = this.getSyncedTime();
                    const dateStr = syncedUTC.toISOString().slice(0, 10);
                    const timeStr = syncedUTC.toISOString().slice(11, 19);

                    infoBar.innerHTML = `
                        <span>${freqMHz} MHz</span> &bull; 
                        <span>${mode}</span> &bull; 
                        <span>${band}</span>
                        <span style="float: right;">${dateStr} ${timeStr} UTC</span>
                    `;
                } catch (error) {
                    // Fail silently if elements are not ready
                }
            }

            loadQsoLog() {
                const savedLog = localStorage.getItem('qmxQsoLog');
                if (savedLog) {
                    this.qsoLog = JSON.parse(savedLog);
                }
                this.renderQsoLog();
            }

            saveQsoLog() {
                localStorage.setItem('qmxQsoLog', JSON.stringify(this.qsoLog));
            }

            logQso() {
                const callsign = document.getElementById('qsoCallsign').value.trim().toUpperCase();
                if (!callsign) {
                    alert('Callsign is required.');
                    document.getElementById('qsoCallsign').focus();
                    return;
                }

                const qso = {
                    id: Date.now(),
                    call: callsign,
                    rstSent: document.getElementById('qsoRstSent').value.trim(),
                    rstRcvd: document.getElementById('qsoRstRcvd').value.trim(),
                    name: document.getElementById('qsoName').value.trim(),
                    qth: document.getElementById('qsoQth').value.trim(),
                    comments: document.getElementById('qsoComments').value.trim(),
                    freq: (this.frequency / 1000000).toFixed(6),
                    mode: this.mode,
                    band: this.band + 'm',
                    time: this.getSyncedTime().toISOString()
                };
                
                this.qsoLog.unshift(qso);
                this.saveQsoLog();
                this.renderQsoLog();
                this.clearQsoInputs(false);
            }

            clearQsoInputs(clearAll = true) {
                document.getElementById('qsoCallsign').value = '';
                document.getElementById('qsoName').value = '';
                document.getElementById('qsoQth').value = '';
                document.getElementById('qsoComments').value = '';
                if(clearAll) {
                   document.getElementById('qsoRstSent').value = '599';
                   document.getElementById('qsoRstRcvd').value = '599';
                }
                document.getElementById('qsoCallsign').focus();
            }

            clearLog() {
                if (confirm(`Are you sure you want to delete all ${this.qsoLog.length} logged QSOs? This cannot be undone.`)) {
                    this.qsoLog = [];
                    this.saveQsoLog();
                    this.renderQsoLog();
                    this.logCAT('QSO Log cleared.', 'info');
                }
            }

            renderQsoLog() {
                const logBody = document.getElementById('qsoLogBody');
                const qsoCount = document.getElementById('qsoCount');
                
                logBody.innerHTML = '';
                
                const filteredLog = this.qsoLog.filter(qso => 
                    qso.call.toUpperCase().includes(this.qsoLogFilter.toUpperCase())
                );

                if (filteredLog.length === 0) {
                    logBody.innerHTML = `<div class="log-empty-msg">${this.qsoLog.length > 0 ? 'No matching QSOs' : 'No QSOs logged yet'}</div>`;
                } else {
                    filteredLog.forEach(qso => {
                        const row = document.createElement('div');
                        row.className = 'log-row';
                        
                        const time = new Date(qso.time);
                        const timeStr = `${time.getUTCHours().toString().padStart(2, '0')}:${time.getUTCMinutes().toString().padStart(2, '0')}`;
                        const freqStr = parseFloat(qso.freq).toFixed(3);

                        row.innerHTML = `
                            <div>${timeStr}</div>
                            <div>${qso.call}</div>
                            <div>${freqStr}</div>
                            <div>${qso.mode}</div>
                            <div>${qso.rstRcvd}</div>
                        `;
                        row.title = `Date: ${time.toISOString().slice(0,10)}\nName: ${qso.name}\nQTH: ${qso.qth}\nComments: ${qso.comments}`;
                        logBody.appendChild(row);
                    });
                }
                
                qsoCount.textContent = this.qsoLog.length;
            }

            exportAdif() {
                if (this.qsoLog.length === 0) {
                    alert('Log is empty. Nothing to export.');
                    return;
                }

                let adifContent = "Generated by QMX+ Professional QRP Communications Interface\n<EOH>\n\n";

                this.qsoLog.slice().reverse().forEach(qso => {
                    const time = new Date(qso.time);
                    const qsoDate = time.toISOString().slice(0, 10).replace(/-/g, '');
                    const timeOn = time.toISOString().slice(11, 19).replace(/:/g, '');

                    let record = '';
                    const addField = (name, value) => {
                        if (value) {
                            const val = String(value);
                            record += `<${name}:${val.length}>${val} `;
                        }
                    };

                    addField('CALL', qso.call);
                    addField('QSO_DATE', qsoDate);
                    addField('TIME_ON', timeOn);
                    addField('BAND', qso.band.toUpperCase());
                    addField('FREQ', qso.freq);
                    addField('MODE', qso.mode);
                    addField('RST_SENT', qso.rstSent);
                    addField('RST_RCVD', qso.rstRcvd);
                    addField('NAME', qso.name);
                    addField('QTH', qso.qth);
                    addField('COMMENT', qso.comments);
                    
                    adifContent += record.trim() + '<EOR>\n';
                });

                const blob = new Blob([adifContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qmx_log_${new Date().toISOString().slice(0, 10)}.adi`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('QSO log exported to ADIF.', 'info');
            }

            importAdif(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        const newQsos = this.parseAdif(content);
                        if (newQsos.length === 0) {
                            alert('No valid QSO records found in the file.');
                            return;
                        }

                        if (confirm(`Found ${newQsos.length} QSOs. Do you want to add them to your log?`)) {
                            const existingKeys = new Set(this.qsoLog.map(q => `${q.call}-${q.time.slice(0,16)}`));
                            const addedQsos = [];
                            newQsos.reverse().forEach(qso => {
                                const key = `${qso.call}-${qso.time.slice(0,16)}`;
                                if (!existingKeys.has(key)) {
                                    this.qsoLog.unshift(qso);
                                    addedQsos.push(qso);
                                }
                            });
                            
                            this.qsoLog.sort((a, b) => new Date(b.time) - new Date(a.time));
                            this.saveQsoLog();
                            this.renderQsoLog();
                            alert(`Successfully imported ${addedQsos.length} new QSOs.`);
                            this.logCAT(`Imported ${addedQsos.length} QSOs from ADIF file.`, 'info');
                        }
                    } catch (error) {
                        alert('Failed to parse ADIF file. Error: ' + error.message);
                        console.error('ADIF Parse Error:', error);
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file);
            }

            parseAdif(adifContent) {
                const qsos = [];
                const records = adifContent.toUpperCase().split(/<EOR>/i);

                for (const record of records) {
                    if (!record.includes('<CALL')) continue;

                    let qso = { id: Date.now() + Math.random() };
                    const fields = record.match(/<[A-Z0-9_]+:\d+>[\s\S]*?(?=\s*<|$)/g) || [];

                    for (const field of fields) {
                        const match = field.match(/<([A-Z0-9_]+):\d+>([\s\S]*)/);
                        if (match) {
                            const [, key, value] = match;
                            qso[key] = value.trim();
                        }
                    }
                    
                    if (qso.CALL && qso.QSO_DATE && qso.TIME_ON) {
                        const date = `${qso.QSO_DATE.slice(0,4)}-${qso.QSO_DATE.slice(4,6)}-${qso.QSO_DATE.slice(6,8)}`;
                        const time = `${qso.TIME_ON.slice(0,2)}:${qso.TIME_ON.slice(2,4)}:${qso.TIME_ON.slice(4,6)}`;
                        const fullIsoTime = new Date(`${date}T${time}Z`).toISOString();

                        qsos.push({
                            id: qso.id,
                            call: qso.CALL || '',
                            rstSent: qso.RST_SENT || '',
                            rstRcvd: qso.RST_RCVD || '',
                            name: qso.NAME || '',
                            qth: qso.QTH || '',
                            comments: qso.COMMENT || '',
                            freq: qso.FREQ || '',
                            mode: qso.MODE || '',
                            band: qso.BAND ? (qso.BAND.endsWith('M') ? qso.BAND : qso.BAND + 'M') : '',
                            time: fullIsoTime,
                        });
                    }
                }
                return qsos;
            }

            initVolumeControl() {
                try {
                    const volumeKnob = document.getElementById('volumeKnob');
                    this.updateVolumeUI();
                    volumeKnob.addEventListener('mousedown', this.startVolumeAdjust.bind(this));
                    volumeKnob.addEventListener('touchstart', this.startVolumeAdjust.bind(this), { passive: false });
                    volumeKnob.addEventListener('wheel', this.handleVolumeWheel.bind(this));
                    volumeKnob.addEventListener('keydown', this.handleVolumeKeyboard.bind(this));
                    console.log('Volume control initialized');
                } catch (error) {
                    console.error('Error initializing volume control:', error);
                }
            }

            startVolumeAdjust(e) {
                e.preventDefault();
                this.isVolumeAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueVolumeAdjust = this.continueVolumeAdjust.bind(this);
                this.boundStopVolumeAdjust = this.stopVolumeAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.volumeLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.addEventListener('mouseup', this.boundStopVolumeAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.volumeLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueVolumeAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopVolumeAdjust);
                }
            }

            continueVolumeAdjust(e) {
                if (!this.isVolumeAdjusting) return;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    const volumeKnob = document.getElementById('volumeKnob');
                    const rect = volumeKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.volumeLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 1.2;
                    deltaAngle *= sensitivity;
                    const newRotation = this.volumeKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.volumeKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    volumeKnob.style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                    const newVolumeLevel = Math.round(((this.volumeKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newVolumeLevel !== this.volumeLevel) {
                        this.volumeLevel = newVolumeLevel;
                        this.updateVolumeUI();
                        this.sendVolumeDynamically();
                    }
                    this.volumeLastAngle = currentAngle;
                    this.volumeAnimationFrame = null;
                });
            }

            stopVolumeAdjust() {
                this.isVolumeAdjusting = false;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                    this.volumeAnimationFrame = null;
                }
                if (this.boundContinueVolumeAdjust && this.boundStopVolumeAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('mouseup', this.boundStopVolumeAdjust);
                    document.removeEventListener('touchmove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('touchend', this.boundStopVolumeAdjust);
                    this.boundContinueVolumeAdjust = null;
                    this.boundStopVolumeAdjust = null;
                }
                this.sendVolumeCommand();
            }

            handleVolumeKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustVolume(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustVolume(5);
                }
            }

            handleVolumeWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const volumeDelta = steps * 5;
                this.adjustVolume(volumeDelta);
            }

            adjustVolume(delta) {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel + delta));
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    this.updateVolumeUI();
                    this.sendVolumeCommand();
                    this.volumeAnimationFrame = null;
                });
            }
			
            updateVolumeUI() {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel));
                this.volumeKnobRotation = this.minRotation + (this.volumeLevel / 100) * this.totalRotationRange;
                document.getElementById('volumeKnob').style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                document.getElementById('volumeLevel').textContent = `${this.volumeLevel}%`;
                document.getElementById('volumeKnob').setAttribute('aria-valuenow', this.volumeLevel);
            }

            sendVolumeDynamically() {
                if (this.volumeTimeout) {
                    clearTimeout(this.volumeTimeout);
                }
                this.volumeTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const scaledVolume = this.volumeToCAT(this.volumeLevel);
                        
                        this.sendCommand(`AG${scaledVolume.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Volume update error:", e);
                        });
                    }
                    this.volumeTimeout = null;
                }, 50);
            }

            async sendVolumeCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const scaledVolume = this.volumeToCAT(this.volumeLevel);
                    await this.sendCommand(`AG${scaledVolume.toString().padStart(3, '0')}`);
                    this.logCAT(`Volume set to ${this.volumeLevel}%`, 'info');
                } catch (e) {
                    this.logCAT(`Volume command error: ${e.message}`, 'error');
                }
            }

            volumeToCAT(volumePercent) {
                if (volumePercent <= 0) return 0;
                if (volumePercent >= 100) return 255;
                
                const normalizedInput = volumePercent / 100;
                const logScaled = (Math.pow(10, normalizedInput * 2) - 1) / 99;
                return Math.round(logScaled * 255);
            }

            catToVolume(catValue) {
                if (catValue <= 0) return 0;
                if (catValue >= 255) return 100;
                
                const normalized = catValue / 255;
                const linearValue = (normalized * 99 + 1);
                const volumePercent = (Math.log10(linearValue) / 2) * 100;
                return Math.round(Math.max(0, Math.min(100, volumePercent)));
            }

            initRFGainControl() {
                try {
                    const rfGainKnob = document.getElementById('rfGainKnob');
                    const rfGainLevel = document.getElementById('rfGainLevel');
                    this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                    rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                    rfGainLevel.textContent = `${this.rfGainLevel} wpm`;
                    rfGainKnob.addEventListener('mousedown', this.startRFGainAdjust.bind(this));
                    rfGainKnob.addEventListener('touchstart', this.startRFGainAdjust.bind(this), { passive: false });
                    rfGainKnob.addEventListener('wheel', this.handleRFGainWheel.bind(this));
                    rfGainKnob.addEventListener('keydown', this.handleRFGainKeyboard.bind(this));
                    rfGainKnob.setAttribute('aria-valuenow', this.rfGainLevel);
                    console.log('Keyer initialized');
                } catch (error) {
                    console.error('Error initializing Keyer:', error);
                }
            }

            startRFGainAdjust(e) {
                e.preventDefault();
                this.isRFGainAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueRFGainAdjust = this.continueRFGainAdjust.bind(this);
                this.boundStopRFGainAdjust = this.stopRFGainAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.rfGainLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueRFGainAdjust);
                    document.addEventListener('mouseup', this.boundStopRFGainAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.rfGainLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueRFGainAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopRFGainAdjust);
                }
            }

            continueRFGainAdjust(e) {
                if (!this.isRFGainAdjusting) return;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    const rfGainKnob = document.getElementById('rfGainKnob');
                    const rect = rfGainKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
                    if (distance < rect.width * 2) {
                        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                        let deltaAngle = currentAngle - this.rfGainLastAngle;
                        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                        const sensitivity = 0.7;
                        deltaAngle *= sensitivity;
                        const newRotation = this.rfGainKnobRotation + (deltaAngle * 180 / Math.PI);
                        this.rfGainKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                        rfGainKnob.style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                        const newRFGainLevel = Math.round(((this.rfGainKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                        if (newRFGainLevel !== this.rfGainLevel) {
                            this.rfGainLevel = newRFGainLevel;
                            this.updateRFGainLevel();
                            this.sendRFGainDynamically();
                        }
                        this.rfGainLastAngle = currentAngle;
                    }
                    this.rfGainAnimationFrame = null;
                });
            }

            stopRFGainAdjust() {
                this.isRFGainAdjusting = false;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                    this.rfGainAnimationFrame = null;
                }
                if (this.boundContinueRFGainAdjust && this.boundStopRFGainAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueRFGainAdjust);
                    document.removeEventListener('mouseup', this.boundStopRFGainAdjust);
                    document.removeEventListener('touchmove', this.boundContinueRFGainAdjust);
                    document.removeEventListener('touchend', this.boundStopRFGainAdjust);
                    this.boundContinueRFGainAdjust = null;
                    this.boundStopRFGainAdjust = null;
                }
                this.sendRFGainCommand();
            }

            handleRFGainKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustRFGain(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustRFGain(5);
                }
            }

            handleRFGainWheel(e) {
                e.preventDefault();
                let steps = e.deltaY > 0 ? -1 : 1;
                const cwSpeedDelta = steps * 1;
                const currentCWSpeed = Math.round(5 + (this.rfGainLevel / 100) * 45);
                const newCWSpeed = Math.max(5, Math.min(50, currentCWSpeed + cwSpeedDelta));
                this.rfGainLevel = ((newCWSpeed - 5) / 45) * 100;
                this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                    this.updateRFGainLevel();
                    this.sendRFGainCommand();
                    this.rfGainAnimationFrame = null;
                });
            }

            adjustRFGain(delta) {
                this.rfGainLevel = Math.max(0, Math.min(100, this.rfGainLevel + delta));
                this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                if (this.rfGainAnimationFrame) {
                    cancelAnimationFrame(this.rfGainAnimationFrame);
                }
                this.rfGainAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                    this.updateRFGainLevel();
                    this.sendRFGainCommand();
                    this.rfGainAnimationFrame = null;
                });
            }

            updateRFGainLevel() {
                const cwSpeed = Math.round(5 + (this.rfGainLevel / 100) * 45);
                document.getElementById('rfGainLevel').textContent = `${cwSpeed} WPM`;
                document.getElementById('rfGainKnob').setAttribute('aria-valuenow', cwSpeed);
            }

            sendRFGainDynamically() {
                if (this.rfGainTimeout) {
                    clearTimeout(this.rfGainTimeout);
                }
                this.rfGainTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const cwSpeed = Math.round(5 + (this.rfGainLevel / 100) * 45);
                        this.sendCommand(`KS${cwSpeed.toString().padStart(3, '0')}`).catch(e => {
                            console.error("CW Speed update error:", e);
                        });
                    }
                    this.rfGainTimeout = null;
                }, 50);
            }

            async sendRFGainCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const cwSpeed = Math.round(5 + (this.rfGainLevel / 100) * 45);
                    await this.sendCommand(`KS${cwSpeed.toString().padStart(3, '0')}`);
                    this.logCAT(`CW Speed set to ${cwSpeed} WPM`, 'info');
                } catch (e) {
                    this.logCAT(`CW Speed command error: ${e.message}`, 'error');
                }
            }

            initPowerControl() {
                try {
                    const powerKnob = document.getElementById('powerKnob');
                    const powerLevel = document.getElementById('powerLevel');
                    this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    powerKnob.style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    powerLevel.textContent = `${(this.powerLevel / 10).toFixed(1)}W`;
                    powerKnob.addEventListener('mousedown', this.startPowerAdjust.bind(this));
                    powerKnob.addEventListener('touchstart', this.startPowerAdjust.bind(this), { passive: false });
                    powerKnob.addEventListener('wheel', this.handlePowerWheel.bind(this));
                    powerKnob.addEventListener('keydown', this.handlePowerKeyboard.bind(this));
                    powerKnob.setAttribute('aria-valuenow', this.powerLevel);
                    console.log('Power control initialized at', (this.powerLevel / 10).toFixed(1), 'W');
                } catch (error) {
                    console.error('Error initializing Power control:', error);
                }
            }

            startPowerAdjust(e) {
                e.preventDefault();
                this.isPowerAdjusting = true;
                this.powerLevelBeforeAdjust = this.powerLevel;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinuePowerAdjust = this.continuePowerAdjust.bind(this);
                this.boundStopPowerAdjust = this.stopPowerAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.powerLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinuePowerAdjust);
                    document.addEventListener('mouseup', this.boundStopPowerAdjust);
                    document.addEventListener('mouseleave', this.boundStopPowerAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.powerLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinuePowerAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopPowerAdjust);
                    document.addEventListener('touchcancel', this.boundStopPowerAdjust);
                }
            }

            continuePowerAdjust(e) {
                if (!this.isPowerAdjusting) return;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                }
                this.powerAnimationFrame = requestAnimationFrame(() => {
                    const powerKnob = document.getElementById('powerKnob');
                    const rect = powerKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.powerLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 0.7;
                    deltaAngle *= sensitivity;
                    const newRotation = this.powerKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.powerKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    powerKnob.style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    const normalizedRotation = (this.powerKnobRotation - this.minRotation) / this.totalRotationRange;
                    const newPowerLevel = Math.round(normalizedRotation * 50);
                    if (newPowerLevel !== this.powerLevel && newPowerLevel >= 0 && newPowerLevel <= 50) {
                        this.powerLevel = newPowerLevel;
                        this.updatePowerLevel();
                        this.sendPowerDynamically();
                    }
                    this.powerLastAngle = currentAngle;
                    this.powerAnimationFrame = null;
                });
            }

            stopPowerAdjust() {
                this.isPowerAdjusting = false;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                    this.powerAnimationFrame = null;
                }
                if (this.boundContinuePowerAdjust && this.boundStopPowerAdjust) {
                    document.removeEventListener('mousemove', this.boundContinuePowerAdjust);
                    document.removeEventListener('mouseup', this.boundStopPowerAdjust);
                    document.removeEventListener('mouseleave', this.boundStopPowerAdjust);
                    document.removeEventListener('touchmove', this.boundContinuePowerAdjust);
                    document.removeEventListener('touchend', this.boundStopPowerAdjust);
                    document.removeEventListener('touchcancel', this.boundStopPowerAdjust);
                    this.boundContinuePowerAdjust = null;
                    this.boundStopPowerAdjust = null;
                }
                if (this.powerLevel < 0 || this.powerLevel > 50 || isNaN(this.powerLevel)) {
                    this.powerLevel = this.powerLevelBeforeAdjust || 50;
                    this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                }
                this.updatePowerLevel();
                this.sendPowerCommand();
            }

            handlePowerKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustPower(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustPower(5);
                }
            }

            handlePowerWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const powerDelta = steps * 5;
                this.adjustPower(powerDelta);
            }

            adjustPower(delta) {
                this.powerLevel = Math.max(0, Math.min(50, this.powerLevel + delta));
                this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                if (this.powerAnimationFrame) {
                    cancelAnimationFrame(this.powerAnimationFrame);
                }
                this.powerAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    this.updatePowerLevel();
                    this.sendPowerCommand();
                    this.powerAnimationFrame = null;
                });
            }

            updatePowerLevel() {
                const previousLevel = this.powerLevel;
                this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                if (previousLevel > 0 && this.powerLevel === 0 && !this.isPowerAdjusting) {
                    console.warn('Power level unexpectedly dropped to 0 from', previousLevel);
                }
                const watts = (this.powerLevel / 10).toFixed(1);
                document.getElementById('powerLevel').textContent = `${watts}W`;
                document.getElementById('powerKnob').setAttribute('aria-valuenow', this.powerLevel);
            }

            sendPowerDynamically() {
                if (this.powerTimeout) {
                    clearTimeout(this.powerTimeout);
                }
                this.powerTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const validPowerLevel = Math.max(0, Math.min(50, this.powerLevel));
                        this.sendCommand(`PC${validPowerLevel.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Power update error:", e);
                        });
                    }
                    this.powerTimeout = null;
                }, 50);
            }

            async sendPowerCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    this.powerLevel = Math.max(0, Math.min(50, this.powerLevel));
                    await this.sendCommand(`PC${this.powerLevel.toString().padStart(3, '0')}`);
                    this.logCAT(`Power set to ${(this.powerLevel / 10).toFixed(1)}W`, 'info');
                } catch (e) {
                    this.logCAT(`Power command error: ${e.message}`, 'error');
                }
            }

            initTuningKnob() {
                try {
                    const tuningKnob = document.getElementById('tuningKnob');
                    this.createFrequencyMarkings();
                    this.tuningKnobRotation = 0;
                    tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    tuningKnob.addEventListener('mousedown', this.startTuningAdjust.bind(this));
                    tuningKnob.addEventListener('touchstart', this.startTuningAdjust.bind(this), { passive: false });
                    tuningKnob.addEventListener('wheel', this.handleTuningWheel.bind(this));
                    tuningKnob.addEventListener('keydown', this.handleTuningKeyboard.bind(this));
                    tuningKnob.setAttribute('aria-valuenow', this.frequency);
                    console.log('CSS tuning knob initialized');
                } catch (error) {
                    console.error('Error initializing tuning knob:', error);
                }
            }

            createFrequencyMarkings() {
                const markingsContainer = document.getElementById('frequencyMarkings');
                markingsContainer.innerHTML = '';
                for (let i = 0; i < 72; i++) {
                    const angle = (i / 72) * 360;
                    const isLarge = i % 6 === 0;
                    const mark = document.createElement('div');
                    mark.className = `frequency-mark ${isLarge ? 'major' : 'minor'}`;
                    mark.style.transform = `rotate(${angle}deg) translate(0, -140px)`;
                    mark.style.left = '50%';
                    mark.style.top = '50%';
                    mark.style.marginLeft = isLarge ? '-1.5px' : '-0.5px';
                    mark.style.marginTop = isLarge ? '-10px' : '-5px';
                    markingsContainer.appendChild(mark);
                }
            }

            startTuningAdjust(e) {
                e.preventDefault();
                this.isTuningAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueTuningAdjust = this.continueTuningAdjust.bind(this);
                this.boundStopTuningAdjust = this.stopTuningAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.tuningLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.addEventListener('mouseup', this.boundStopTuningAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.tuningLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueTuningAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopTuningAdjust);
                }
            }

            continueTuningAdjust(e) {
                if (!this.isTuningAdjusting) return;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    const tuningKnob = document.getElementById('tuningKnob');
                    const rect = tuningKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
                    if (distance < rect.width * 2) {
                        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                        let deltaAngle = currentAngle - this.tuningLastAngle;
                        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                        const sensitivity = 1.5;
                        deltaAngle *= sensitivity;
                        this.tuningKnobRotation += (deltaAngle * 180 / Math.PI);
                        tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                        const freqDelta = (deltaAngle * 180 / Math.PI) * this.stepSize * 0.3;
                        if (Math.abs(freqDelta) > 0.1) {
                            this.updateFrequency(freqDelta);
                            this.sendFrequencyImmediate();
                        }
                        this.tuningLastAngle = currentAngle;
                    }
                    this.tuningAnimationFrame = null;
                });
            }

            stopTuningAdjust() {
                this.isTuningAdjusting = false;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                    this.tuningAnimationFrame = null;
                }
                if (this.boundContinueTuningAdjust && this.boundStopTuningAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.removeEventListener('mouseup', this.boundStopTuningAdjust);
                    document.removeEventListener('touchmove', this.boundContinueTuningAdjust);
                    document.removeEventListener('touchend', this.boundStopTuningAdjust);
                    this.boundContinueTuningAdjust = null;
                    this.boundStopTuningAdjust = null;
                }
                this.sendFrequencyImmediate();
            }

            handleTuningWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const freqDelta = steps * this.stepSize;
                this.updateFrequency(freqDelta);
                const rotationDelta = steps * 2;
                this.tuningKnobRotation += rotationDelta;
                document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                this.sendFrequencyDynamically();
            }

            handleTuningKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustFrequency(-this.stepSize);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustFrequency(this.stepSize);
                }
            }

            adjustFrequency(delta) {
                this.updateFrequency(delta);
                const rotationDelta = (delta / this.stepSize) * 2;
                this.tuningKnobRotation += rotationDelta;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    this.sendFrequencyImmediate();
                    this.tuningAnimationFrame = null;
                });
            }

           sendFrequencyImmediate() {
    if (this.connected && this.port && this.writer) {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        this.sendCommand(`${vfoCommand}${freqStr}`).catch(e => {
            console.error("Frequency update error:", e);
        });
    }
}

           sendFrequencyDynamically() {
    if (this.catTimeout) {
        clearTimeout(this.catTimeout);
    }
    this.catTimeout = setTimeout(() => {
        if (this.connected && this.port && this.writer) {
            const freqStr = this.frequency.toString().padStart(11, '0');
            const vfoCommand = this.getVFOCommand();
            this.sendCommand(`${vfoCommand}${freqStr}`).catch(e => {
                console.error("Frequency update error:", e);
            });
        }
        this.catTimeout = null;
    }, 5);
}
			
            startPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                this.pollingInterval = setInterval(async () => {
                    if (this.connected) {
                        await this.sendCommand('IF');
                        await this.sendCommand('LC');
                        await this.sendCommand('SM');
                        await this.sendCommand('SW');
                        await this.sendCommand('KS');
						await this.sendCommand('AG0');
                    }
                }, 350);
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                }
            }

            parseIfResponse(data) {
                try {
                    const freq = parseInt(data.substring(0, 11));
                    if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                    const txStatus = data.substring(26, 27);
                    const isTransmitting = (txStatus === '1');
                    if (isTransmitting !== this.transmitting) {
                        this.transmitting = isTransmitting;
                        this.updateTXStatus();
                    }
                    const catMode = data.substring(27, 28);
                    this.updateModeFromCAT(catMode);
                } catch (error) {
                    this.logCAT(`Error parsing IF response: ${error.message}`, 'error');
                }
            }

          async sendFrequencyCommand() {
    if (!this.connected || !this.port || !this.writer) return;
    try {
        const freqStr = this.frequency.toString().padStart(11, '0');
        const vfoCommand = this.getVFOCommand();
        await this.sendCommand(`${vfoCommand}${freqStr}`);
        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
        const displayStr = this.frequency.toString().padStart(9, '0');
        const mhz = displayStr.substring(0, 3);
        const khz = displayStr.substring(3, 6); 
        const hz = displayStr.substring(6, 9);
        this.logCAT(`VFO ${this.currentVFO} frequency set to ${mhz}.${khz}.${hz} Hz`, 'info');
    } catch (e) {
        this.logCAT(`Frequency command error: ${e.message}`, 'error');
    }
}

            async updateFrequency(delta) {
                this.frequency += delta;
                this.frequency = Math.max(100000, Math.min(999999999, this.frequency));
                this.frequency = Math.round(this.frequency);
                this.updateDisplay();
                this.saveLastFrequency();
            }

            async connectSerial() {
                try {
                    if (!navigator.serial) {
                        this.logCAT('WebSerial API not supported', 'error');
                        return false;
                    }

                    const selectedBaud = parseInt(document.getElementById('baudRate').value);
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ 
                        baudRate: selectedBaud,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    
                    this.connected = true;
                    this.lastCommandTime = Date.now();
                    this.updateConnectionStatus();
                    this.logCAT(`Serial connected at ${selectedBaud} baud`, 'rx');
                    await this.sendCommand('QB0');
                    await this.sendCommand('Q90'); 
                    
                    this.startReading();
                    this.startConnectionHealthCheck();
                    await this.initializeRadio();
                    this.startPolling();
                    return true;
                } catch (error) {
                    this.logCAT(`Connection failed: ${error.message}`, 'error');
                    this.connected = false;
                    this.updateConnectionStatus();
                    return false;
                }
            }

            async disconnectSerial() {
                try {
                    this.connected = false;
                    if (this.port) {
                        await this.sendCommand('QB1');
                    }
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.stopPolling();
                    if (this.reader) {
                        try {
                            await this.reader.cancel();
                        } catch (e) {
                            console.log('Reader cancel error:', e);
                        }
                        try {
                            await this.reader.releaseLock();
                        } catch (e) {
                            console.log('Reader release error:', e);
                        }
                        this.reader = null;
                    }
                    if (this.writer) {
                        try {
                            await this.writer.releaseLock();
                        } catch (e) {
                            console.log('Writer release error:', e);
                        }
                        this.writer = null;
                    }
                    if (this.port) {
                        try {
                            await this.port.close();
                        } catch (e) {
                            console.log('Port close error:', e);
                        }
                        this.port = null;
                    }
                    this.logCAT('Serial disconnected', 'rx');
                } catch (error) {
                    this.connected = false;
                    this.reader = null;
                    this.writer = null;
                    this.port = null;
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.logCAT(`Disconnect error: ${error.message}`, 'rx');
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.connected && this.reader) {
                        try {
                            const { value, done } = await this.reader.read();
                            if (done) {
                                this.logCAT('Hardware disconnected', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            }
                            const text = new TextDecoder().decode(value);
                            buffer += text;
                            this.lastCommandTime = Date.now();
                            while (buffer.includes(';')) {
                                const end = buffer.indexOf(';');
                                const response = buffer.substring(0, end);
                                buffer = buffer.substring(end + 1);
                                if (response.trim()) {
                                    this.processResponse(response.trim());
                                }
                            }
                        } catch (readError) {
                            if (readError.name === 'NetworkError' || 
                                readError.message.includes('device has been lost') ||
                                readError.message.includes('The port is not open') ||
                                readError.code === 19) {
                                this.logCAT('Hardware disconnected during read', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            } else {
                                this.logCAT(`Read error: ${readError.message}`, 'error');
                            }
                        }
                    }
                } catch (error) {
                    this.logCAT(`Reader stream error: ${error.message}`, 'error');
                    if (this.connected) {
                        this.handleHardwareDisconnect();
                    }
                }
            }

            async sendCommand(command) {
                if (!this.connected || !this.writer) {
                    return null;
                }
                try {
                    const fullCommand = command + ';';
                    const data = new TextEncoder().encode(fullCommand);
                    await this.writer.write(data);
                    this.logCAT(command, 'tx');
                    this.lastCommandTime = Date.now();
                    return true;
                } catch (error) {
                    if (error.name === 'NetworkError' || 
                        error.message.includes('device has been lost') ||
                        error.message.includes('The port is not open') ||
                        error.code === 19) {
                        this.logCAT('Hardware disconnected during command', 'error');
                        this.handleHardwareDisconnect();
                    } else {
                        this.logCAT(`Send error: ${error.message}`, 'error');
                    }
                    return false;
                }
            }

            handleHardwareDisconnect() {
                if (!this.connected) return;
                this.connected = false;
                this.reader = null;
                this.writer = null;
                this.port = null;
                if (this.connectionCheckTimeout) {
                    clearTimeout(this.connectionCheckTimeout);
                    this.connectionCheckTimeout = null;
                }
                this.updateConnectionStatus();
                this.logCAT('Auto-disconnect complete', 'rx');
            }

            startConnectionHealthCheck() {
                if (!this.connected) return;
                const now = Date.now();
                const timeSinceLastCommand = now - this.lastCommandTime;
                if (timeSinceLastCommand > 10000 && this.connected) {
                    this.sendCommand('ID').catch(() => {
                        this.logCAT('Connection health check failed', 'error');
                        this.handleHardwareDisconnect();
                    });
                }
                this.connectionCheckTimeout = setTimeout(() => {
                    this.startConnectionHealthCheck();
                }, 5000);
            }

            processResponse(response) {
                this.logCAT(response, 'rx');
                if (response.startsWith('IF')) {
                    this.parseIfResponse(response.substring(2));
                } else if (response.startsWith('LC')) {
                    let lcdData = response.substring(2);
                    if (lcdData.length < 32) {
                        lcdData = lcdData.padEnd(32, ' ');
                    }
                    const row1 = lcdData.substring(0, 16);
                    const row2 = lcdData.substring(16, 32);
                    this.updateLcdDisplay(row1, row2);
                } else if (response.startsWith('AG')) {
                    const gain = parseInt(response.substring(2));
                    if (!isNaN(gain) && !this.isVolumeAdjusting) {
                        this.volumeLevel = this.catToVolume(gain);
                        this.updateVolumeUI();
                    }
                else if (response.startsWith('FB')) {
    const freq = parseInt(response.substring(2));
    if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'B') {
        this.frequency = freq;
        this.updateDisplay();
        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
    }
}

// And modify the existing FA response handler:
else if (response.startsWith('FA')) {
    const freq = parseInt(response.substring(2));
    if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'A') {
        this.frequency = freq;
        this.updateDisplay();
        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
    }
}

                } else if (response.startsWith('SM')) {
                    const sMeter = parseInt(response.substring(2));
                    if (!isNaN(sMeter)) {
                        this.updateSMeter(sMeter);
                    }
                } else if (response.startsWith('SW')) {
                    const swr = parseInt(response.substring(2));
                    if (!isNaN(swr)) {
                        this.updateSWRMeter(swr);
                    }
                } else if (response.startsWith('PC')) {
                    const powerTenths = parseInt(response.substring(2));
                    if (!isNaN(powerTenths) && !this.isPowerAdjusting) {
                        this.powerLevel = powerTenths;
                        this.updatePowerLevel();
                        this.powerKnobRotation = this.minRotation + (this.powerLevel / 50) * this.totalRotationRange;
                        document.getElementById('powerKnob').style.transform = `rotate(${this.powerKnobRotation}deg)`;
                    }
                } else if (response.startsWith('MD')) {
                    const mode = response.substring(2);
                    this.updateModeFromCAT(mode);
                } else if (response.startsWith('KS')) {
                    const wpm = parseInt(response.substring(2));
                    if (!isNaN(wpm) && !this.isRFGainAdjusting && wpm >= 5 && wpm <= 50) {
                        this.rfGainLevel = ((wpm - 5) / 45) * 100;
                        this.updateRFGainLevel();
                        this.rfGainKnobRotation = this.minRotation + (this.rfGainLevel / 100) * this.totalRotationRange;
                        document.getElementById('rfGainKnob').style.transform = `rotate(${this.rfGainKnobRotation}deg)`;
                    }
                } else if (response.startsWith('TX')) {
                    this.transmitting = true;
                    this.updateTXStatus();
                } else if (response.startsWith('RX')) {
                    this.transmitting = false;
                    this.updateTXStatus();
                }
            }

            initMemorySystem() {
                try {
                    const savedMemories = localStorage.getItem('qmxMemoryChannels');
                    if (savedMemories) {
                        this.memoryChannels = JSON.parse(savedMemories);
                    }
                    document.getElementById('storeBtn').addEventListener('click', () => this.setMemoryMode('store'));
                    document.getElementById('recallBtn').addEventListener('click', () => this.setMemoryMode('recall'));
                    document.getElementById('editBtn').addEventListener('click', () => this.setMemoryMode('edit'));
                    document.getElementById('clearBtn').addEventListener('click', () => this.setMemoryMode('clear'));
                    document.getElementById('exportBtn').addEventListener('click', () => this.exportMemories());
                    document.getElementById('importBtn').addEventListener('click', () => {
                        document.getElementById('importFile').click();
                    });
                    document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAllMemories());
                    document.getElementById('importFile').addEventListener('change', (e) => this.importMemories(e));
                    document.querySelectorAll('.memory-btn').forEach((btn) => {
                        const channel = parseInt(btn.dataset.channel);
                        let clickTimer = null;
                        btn.addEventListener('click', (e) => {
                            if (clickTimer) {
                                clearTimeout(clickTimer);
                                clickTimer = null;
                                if (this.memoryMode === 'recall') {
                                    this.storeMemoryChannel(channel);
                                    this.logCAT(`Quick-stored to M${channel}`, 'info');
                                }
                            } else {
                                clickTimer = setTimeout(() => {
                                    clickTimer = null;
                                    this.handleMemoryChannel(channel);
                                }, 250);
                            }
                        });
                        btn.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.editMemoryChannel(channel);
                        });
                    });
                    document.getElementById('saveMemoryEdit').addEventListener('click', () => this.saveMemoryEdit());
                    document.getElementById('cancelMemoryEdit').addEventListener('click', () => this.closeEditModal());
                    document.getElementById('modalOverlay').addEventListener('click', () => this.closeEditModal());
                    this.updateMemoryDisplay();
                    this.setMemoryMode('recall');
                    console.log('Memory system initialized');
                } catch (error) {
                    console.error('Error initializing memory system:', error);
                }
            }

            setMemoryMode(mode) {
                this.memoryMode = mode;
                const buttons = {
                    'store': document.getElementById('storeBtn'),
                    'recall': document.getElementById('recallBtn'),
                    'edit': document.getElementById('editBtn'),
                    'clear': document.getElementById('clearBtn')
                };
                Object.values(buttons).forEach(btn => {
                    btn.classList.remove('btn-primary', 'btn-danger');
                    btn.classList.add('btn-secondary');
                });
                if (buttons[mode]) {
                    buttons[mode].classList.remove('btn-secondary');
                    if (mode === 'clear') {
                        buttons[mode].classList.add('btn-danger');
                    } else {
                        buttons[mode].classList.add('btn-primary');
                    }
                }
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    btn.classList.remove('memory-store-warning');
                    btn.style.cursor = mode === 'recall' ? 'pointer' : 
                                      mode === 'store' ? 'copy' :
                                      mode === 'edit' ? 'text' :
                                      mode === 'clear' ? 'not-allowed' : 'pointer';
                    if (mode === 'store' && this.memoryChannels[index]) {
                        btn.classList.add('memory-store-warning');
                    }
                });
                this.logCAT(`Memory mode: ${mode.toUpperCase()} (${this.getMemoryModeHint(mode)})`, 'info');
            }

            getMemoryModeHint(mode) {
                switch(mode) {
                    case 'recall': return 'Click to recall, double-click to quick-store, right-click to edit';
                    case 'store': return 'Click any memory to store current settings';
                    case 'edit': return 'Click any memory to edit its settings';
                    case 'clear': return 'Click any memory to clear it';
                    default: return '';
                }
            }

            handleMemoryChannel(channel) {
                switch(this.memoryMode) {
                    case 'store': this.storeMemoryChannel(channel); break;
                    case 'recall': this.recallMemoryChannel(channel); break;
                    case 'edit': this.editMemoryChannel(channel); break;
                    case 'clear': this.clearMemoryChannel(channel); break;
                }
            }

            storeMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const existingLabel = this.memoryChannels[channelIndex]?.label || '';
                if (this.memoryChannels[channelIndex]) {
                    const existingMem = this.memoryChannels[channelIndex];
                    const freqMHz = (existingMem.frequency / 1000000).toFixed(3);
                    const label = existingMem.label ? `"${existingMem.label}"` : '';
                    if (!confirm(`Overwrite M${channel}?\n\nCurrent: ${freqMHz} MHz, ${existingMem.mode}${label}\n\nReplace with: ${(this.frequency / 1000000).toFixed(3)} MHz, ${this.mode}?`)) {
                        return;
                    }
                }
                const memoryData = {
                    frequency: this.frequency,
                    mode: this.mode,
                    band: this.band,
                    label: existingLabel,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = channel;
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Stored M${channel}: ${mhz}.${khz}.${hz} Hz, ${this.mode}${existingLabel ? ', "' + existingLabel + '"' : ''}`, 'info');
                setTimeout(() => {
                    this.setMemoryMode('recall');
                }, 1000);
            }

            recallMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                if (!memoryData) {
                    this.logCAT(`Memory M${channel} is empty`, 'error');
                    return;
                }
                this.frequency = memoryData.frequency;
                this.mode = memoryData.mode;
                this.band = memoryData.band;
                this.updateDisplay();
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === this.mode) {
                        btn.classList.add('active');
                    }
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.band === this.band) {
                        btn.classList.add('active');
                    }
                });
              if (this.connected) {
    const freqStr = this.frequency.toString().padStart(11, '0');
    const vfoCommand = this.getVFOCommand();
    this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
        setTimeout(() => {
            this.sendCommand(this.getVFOCommand());
        }, 100);
    }).catch(e => {
        this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
    });
    
    const modeBtn = document.querySelector(`[data-mode="${this.mode}"]`);
    if (modeBtn) {
        const catMode = modeBtn.dataset.catmode;
        this.sendCommand(`MD${catMode}`).catch(e => {
            console.error("Mode command error:", e);
        });
    }
	
	}
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                const label = memoryData.label ? ` "${memoryData.label}"` : '';
                this.logCAT(`Recalled M${channel}${label}: ${mhz}.${khz}.${hz} Hz, ${this.mode}`, 'info');
                this.selectedMemoryChannel = channel;
                this.updateMemoryDisplay();
            }

            editMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                this.editingChannel = channel;
                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('memoryEditModal').classList.add('active');
                document.getElementById('editChannelNumber').textContent = channel;
                const freqInput = document.getElementById('memoryFreqInput');
                const modeSelect = document.getElementById('memoryModeSelect');
                const bandSelect = document.getElementById('memoryBandSelect');
                const labelInput = document.getElementById('memoryLabelInput');
                if (memoryData) {
                    freqInput.value = (memoryData.frequency / 1000000).toFixed(6);
                    modeSelect.value = memoryData.mode;
                    bandSelect.value = memoryData.band;
                    labelInput.value = memoryData.label || '';
                } else {
                    freqInput.value = (this.frequency / 1000000).toFixed(6);
                    modeSelect.value = this.mode;
                    bandSelect.value = this.band;
                    labelInput.value = '';
                }
                freqInput.addEventListener('input', () => {
                    const freqMHz = parseFloat(freqInput.value);
                    if (!isNaN(freqMHz)) {
                        const suggestedBand = this.getBandFromFrequency(freqMHz);
                        if (suggestedBand) {
                            bandSelect.value = suggestedBand;
                        }
                    }
                });
                freqInput.focus();
                freqInput.select();
                const handleEnter = (e) => {
                    if (e.key === 'Enter') {
                        this.saveMemoryEdit();
                    } else if (e.key === 'Escape') {
                        this.closeEditModal();
                    }
                };
                freqInput.onkeydown = handleEnter;
                labelInput.onkeydown = handleEnter;
            }

            saveMemoryEdit() {
                if (this.editingChannel === null) return;
                const channelIndex = this.editingChannel - 1;
                const freqInput = document.getElementById('memoryFreqInput').value.trim();
                const mode = document.getElementById('memoryModeSelect').value;
                const band = document.getElementById('memoryBandSelect').value;
                const label = document.getElementById('memoryLabelInput').value.trim();
                let frequency;
                if (freqInput) {
                    const cleanFreq = freqInput.replace(/[^0-9.]/g, '');
                    const freqMHz = parseFloat(cleanFreq);
                    if (isNaN(freqMHz) || freqMHz < 0.1 || freqMHz > 999.999999) {
                        alert('Please enter a valid frequency');
                        document.getElementById('memoryFreqInput').focus();
                        return;
                    }
                    frequency = Math.round(freqMHz * 1000000);
                } else {
                    alert('Please enter a frequency');
                    document.getElementById('memoryFreqInput').focus();
                    return;
                }
                const memoryData = {
                    frequency: frequency,
                    mode: mode,
                    band: band,
                    label: label,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = this.editingChannel;
                const freqStr = frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Updated M${this.editingChannel}: ${mhz}.${khz}.${hz} Hz, ${mode}, ${band}m${label ? ', "' + label + '"' : ''}`, 'info');
                this.closeEditModal();
            }

            closeEditModal() {
                document.getElementById('modalOverlay').classList.remove('active');
                document.getElementById('memoryEditModal').classList.remove('active');
                this.editingChannel = null;
            }

            clearMemoryChannel(channel) {
                const channelIndex = channel - 1;
                if (this.memoryChannels[channelIndex]) {
                    const memData = this.memoryChannels[channelIndex];
                    const freqMHz = (memData.frequency / 1000000).toFixed(3);
                    const label = memData.label || `M${channel}`;
                    if (confirm(`Clear memory channel M${channel}?\n\nFrequency: ${freqMHz} MHz\nMode: ${memData.mode}\nLabel: ${label}`)) {
                        this.memoryChannels[channelIndex] = null;
                        localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                        this.updateMemoryDisplay();
                        this.logCAT(`Cleared memory channel M${channel}`, 'info');
                        if (this.selectedMemoryChannel === channel) {
                            this.selectedMemoryChannel = null;
                        }
                    }
                } else {
                    this.logCAT(`Memory M${channel} is already empty`, 'error');
                }
            }

            clearAllMemories() {
                const usedMemories = this.memoryChannels.filter(m => m !== null).length;
                if (usedMemories === 0) {
                    this.logCAT('No memory channels to clear', 'info');
                    return;
                }
                if (confirm(`Clear ALL memory channels?\n\nThis will delete ${usedMemories} stored memories.\nThis action cannot be undone!`)) {
                    this.memoryChannels = new Array(10).fill(null);
                    localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                    this.selectedMemoryChannel = null;
                    this.updateMemoryDisplay();
                    this.logCAT(`Cleared all ${usedMemories} memory channels`, 'info');
                }
            }

            updateMemoryDisplay() {
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    const channel = index + 1;
                    const memoryData = this.memoryChannels[index];
                    btn.innerHTML = '';
                    btn.classList.remove('memory-occupied', 'memory-selected', 'memory-store-warning');
                    if (memoryData) {
                        btn.classList.add('memory-occupied');
                        if (this.memoryMode === 'store') {
                            btn.classList.add('memory-store-warning');
                        }
                        const channelSpan = document.createElement('span');
                        channelSpan.textContent = `M${channel}`;
                        btn.appendChild(channelSpan);
                        if (memoryData.label) {
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'memory-label';
                            labelSpan.textContent = memoryData.label;
                            btn.appendChild(labelSpan);
                        }
                        btn.title = `M${channel}: ${(memoryData.frequency / 1000000).toFixed(3)} MHz, ${memoryData.mode}${memoryData.label ? ' - ' + memoryData.label : ''}`;
                    } else {
                        btn.textContent = `M${channel}`;
                        btn.title = `M${channel}: Empty`;
                    }
                    if (this.selectedMemoryChannel === channel) {
                        btn.classList.add('memory-selected');
                    }
                });
            }

            exportMemories() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    memories: this.memoryChannels
                };
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qmx_memories_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('Memory channels exported successfully', 'info');
            }

            importMemories(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        if (importData.memories && Array.isArray(importData.memories)) {
                            if (confirm('This will replace all current memory channels. Continue?')) {
                                this.memoryChannels = importData.memories;
                                localStorage.setItem('qmxMemoryChannels', JSON.stringify(this.memoryChannels));
                                this.updateMemoryDisplay();
                                this.logCAT('Memory channels imported successfully', 'info');
                            }
                        } else {
                            throw new Error('Invalid file format');
                        }
                    } catch (error) {
                        this.logCAT(`Import failed: ${error.message}`, 'error');
                        alert('Failed to import memory file.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            logCAT(message, type = 'info') {
                if (!this.catLogElement) {
                    this.catLogElement = document.getElementById('catLog');
                }
                if (!this.catLogElement) return;
                const entry = document.createElement('div');
                entry.className = `cat-log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `${timestamp} ${type.toUpperCase()}: ${message}`;
                this.catLogElement.appendChild(entry);
                this.catLogElement.scrollTop = this.catLogElement.scrollHeight;
                while (this.catLogElement.children.length > 200) {
                    this.catLogElement.removeChild(this.catLogElement.firstChild);
                }
            }

            async initializeRadio() {
                await this.sendCommand('IF');
                await this.sendCommand('LC');
                await this.sendCommand('FA');
                await this.sendCommand('MD');
                await this.sendCommand('AG0');
                await this.sendCommand('KS');
                await this.sendCommand('SM');
                await this.sendCommand('SW');
                await this.sendCommand('PC');
				this.sendTimeToQMX();
            }

            initEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.disconnectSerial();
                    } else {
                        await this.connectSerial();
                    }
                });
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.mode = btn.dataset.mode;
                        if (this.connected) {
                            const catMode = btn.dataset.catmode;
                            await this.sendCommand(`MD${catMode}`);
                            this.logCAT(`Mode changed to ${this.mode}`, 'info');
                        }
                    });
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.band = btn.dataset.band;
                        this.setBandFrequency(btn.dataset.band);
                    });
                });
                document.getElementById('stepSize').addEventListener('change', (e) => {
                    this.stepSize = parseInt(e.target.value);
                });
                document.getElementById('vfoA').addEventListener('click', async () => {
    this.selectVFO('A');
    if (this.connected) {
        await this.sendCommand('FR0');  // Select VFO A for RX
        await this.sendCommand('FT0');  // Select VFO A for TX
        // Request frequency update for VFO A
        await this.sendCommand('FA');
    }
});

document.getElementById('vfoB').addEventListener('click', async () => {
    this.selectVFO('B');
    if (this.connected) {
        await this.sendCommand('FR1');  // Select VFO B for RX
        await this.sendCommand('FT1');  // Select VFO B for TX
        // Request frequency update for VFO B
        await this.sendCommand('FB');
    }
});
              // This is inside the initEventListeners function

document.getElementById('vfoB').addEventListener('click', async () => {
    this.selectVFO('B');
    if (this.connected) {
        await this.sendCommand('FR1');
        await this.sendCommand('FT1');
        // Add this line to ask for the new VFO's frequency
        await this.sendCommand('FB'); 
    }

                });
                document.getElementById('vfoSwap').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('AB');
                        this.logCAT('VFO A and B swapped', 'info');
                    }
                });
                document.getElementById('vfoCopy').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('A=B');
                        this.logCAT('VFO A copied to VFO B', 'info');
                    }
                });
                document.getElementById('txBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('TX');
                        this.transmitting = true;
                        this.updateTXStatus();
                        this.logCAT('Switched to TRANSMIT mode', 'info');
                    } else {
                        this.logCAT('Cannot transmit - radio not connected', 'error');
                    }
                });
                document.getElementById('rxBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('RX');
                        this.transmitting = false;
                        this.updateTXStatus();
                        this.logCAT('Switched to RECEIVE mode', 'info');
                    } else {
                        this.logCAT('Cannot switch to RX - radio not connected', 'error');
                    }
                });
		  }

           setBandFrequency(band) {
    if (this.lastFrequencies[band]) {
        this.frequency = this.lastFrequencies[band];
        this.updateDisplay();
        if (this.connected) {
            this.sendFrequencyImmediate();
        }
    }
}

            getBandFromFrequency(freqMHz) {
                if (freqMHz >= 1.8 && freqMHz <= 2.0) return '160';
                if (freqMHz >= 3.5 && freqMHz <= 4.0) return '80';
                if (freqMHz >= 7.0 && freqMHz <= 7.3) return '40';
                if (freqMHz >= 10.1 && freqMHz <= 10.15) return '30';
                if (freqMHz >= 14.0 && freqMHz <= 14.35) return '20';
                if (freqMHz >= 18.068 && freqMHz <= 18.168) return '17';
                if (freqMHz >= 21.0 && freqMHz <= 21.45) return '15';
                if (freqMHz >= 24.89 && freqMHz <= 24.99) return '12';
                if (freqMHz >= 28.0 && freqMHz <= 29.7) return '10';
                if (freqMHz >= 50.0 && freqMHz <= 54.0) return '6';
                return null; // MODIFIED: Return null if frequency is out of all defined bands.
            }

         /*   selectVFO(vfo) {
                this.currentVFO = vfo;
                document.querySelectorAll('#vfoA, #vfoB').forEach(btn => {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                });
                document.getElementById(`vfo${vfo}`).classList.remove('btn-secondary');
                document.getElementById(`vfo${vfo}`).classList.add('btn-primary');
            } */
			
			selectVFO(vfo) {
    this.currentVFO = vfo;
    this.updateVFOButtons();
    this.logCAT(`VFO ${vfo} selected`, 'info');
}

            updateConnectionStatus() {
                const btn = document.getElementById('connectBtn');
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const baudDropdown = document.getElementById('baudRate');
                if (this.connected) {
                    btn.textContent = 'Disconnect';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    statusDot.classList.add('connected');
                    statusText.textContent = 'CONNECTED';
                    statusText.className = 'status-text connected';
                    baudDropdown.disabled = true;
                } else {
                    btn.textContent = 'Connect Serial';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'DISCONNECTED';
                    statusText.className = 'status-text disconnected';
                    baudDropdown.disabled = false;
                }
            }

            updateTXStatus() {
                const txBtn = document.getElementById('txBtn');
                const rxBtn = document.getElementById('rxBtn');
                if (this.transmitting) {
                    txBtn.classList.remove('btn-secondary');
                    txBtn.classList.add('btn-danger');
                    rxBtn.classList.remove('btn-primary');
                    rxBtn.classList.add('btn-secondary');
                } else {
                    txBtn.classList.remove('btn-danger');
                    txBtn.classList.add('btn-secondary');
                    rxBtn.classList.remove('btn-secondary');
                    rxBtn.classList.add('btn-primary');
                }
            }

            updateModeFromCAT(catMode) {
                const modeMap = {
                    '1': 'LSB', '2': 'USB', '3': 'CW',
                    '7': 'CW', '6': 'DIGI'
                };
                if (modeMap[catMode]) {
                    this.mode = modeMap[catMode];
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.mode === this.mode) {
                            btn.classList.add('active');
                        }
                    });
                } else {
                    this.logCAT(`Unknown mode code received: ${catMode}`, 'error');
                }
            }

            updateSMeter(value) {
                const meter = document.getElementById('sMeter');
                let percentage = value;
                percentage = Math.max(0, Math.min(100, percentage));
                meter.style.width = percentage + '%';
            }

            updateSWRMeter(value) {
                const meter = document.getElementById('swrMeter');
                const swr = value / 100;
                const percentage = Math.min(100, Math.max(0, (swr - 1) / 4 * 100));
                meter.style.width = percentage + '%';
            }

          updateLcdDisplay(row1, row2) {
    const lcdRow1El = document.getElementById('lcdRow1');
    const lcdRow2El = document.getElementById('lcdRow2');
    
    if (lcdRow1El) {
        lcdRow1El.textContent = row1;
    }
    if (lcdRow2El) {
        lcdRow2El.textContent = row2;
    }
    
    // Auto-detect VFO from LCD display
    // If the first character is 'B', we're on VFO B, otherwise VFO A
    const detectedVFO = (row1 && row1.charAt(0) === 'B') ? 'B' : 'A';
    
    if (detectedVFO !== this.currentVFO) {
        this.currentVFO = detectedVFO;
        this.updateVFOButtons();
        this.logCAT(`VFO switched to ${this.currentVFO} (auto-detected)`, 'info');
    }
}

            updateDisplay() {}

            updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('currentTime').textContent = timeString;
                setTimeout(() => this.updateClock(), 1000);
            }

            async initTimeSync() {
                try {
                    this.logCAT('Initializing time synchronization...', 'info');
                    
                    await this.syncTimeFromServer();
                    
                    this.clockUpdateInterval = setInterval(() => {
                        this.updateSyncedClock();
                        this.updateLoggerInfoBar();
                    }, 1000);
                    
                    this.timeSyncInterval = setInterval(() => {
                        this.syncTimeFromServer();
                    }, 10 * 60 * 1000);
                    
                    console.log('Time synchronization initialized');
                } catch (error) {
                    console.error('Error initializing time sync:', error);
                    this.logCAT(`Time sync init error: ${error.message}`, 'error');
                    this.updateLocalClock();
                }
            }

            async syncTimeFromServer() {
                try {
                    this.logCAT('Synchronizing with time server...', 'info');
                    
                    const timeAPIs = [
                        'https://worldtimeapi.org/api/timezone/Etc/UTC',
                        'https://timeapi.io/api/Time/current/zone?timeZone=UTC',
                        'http://worldclockapi.com/api/json/utc/now'
                    ];
                    
                    let syncSuccessful = false;
                    
                    for (const api of timeAPIs) {
                        try {
                            const response = await fetch(api, {
                                method: 'GET', cache: 'no-cache', headers: { 'Accept': 'application/json' }
                            });
                            
                            if (!response.ok) continue;
                            
                            const data = await response.json();
                            let serverTime;
                            
                            if (data.datetime) serverTime = new Date(data.datetime);
                            else if (data.dateTime) serverTime = new Date(data.dateTime);
                            else if (data.currentDateTime) serverTime = new Date(data.currentDateTime);
                            else continue;
                            
                            const localTime = new Date();
                            this.localTimeOffset = serverTime.getTime() - localTime.getTime();
                            this.lastSyncTime = localTime.getTime();
                            
                            this.logCAT(`Time synced successfully (offset: ${this.localTimeOffset}ms)`, 'info');
                            syncSuccessful = true;
                            
                            this.sendTimeToQMX();
                            break;
                            
                        } catch (apiError) {
                            console.warn(`Time API ${api} failed:`, apiError);
                            continue;
                        }
                    }
                    
                    if (!syncSuccessful) throw new Error('All time APIs failed');
                    
                } catch (error) {
                    console.error('Time sync failed:', error);
                    this.logCAT(`Time sync failed: ${error.message}`, 'error');
                    this.localTimeOffset = 0;
                }
            }

            getSyncedTime() {
                const now = new Date();
                return new Date(now.getTime() + (this.localTimeOffset || 0));
            }

            updateSyncedClock() {
                const syncedUTC = this.getSyncedTime();
                const localTime = new Date(syncedUTC.getTime() - (syncedUTC.getTimezoneOffset() * 60000));
                
                const timeString = localTime.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    const syncAge = this.lastSyncTime ? Date.now() - this.lastSyncTime : Infinity;
                    const syncIndicator = syncAge > 11 * 60 * 1000 ? ' (SYNC?)' : ' (SYNC)';
                    timeElement.textContent = timeString + (this.lastSyncTime ? syncIndicator : ' (LOCAL)');
                }
            }

           



updateVFOButtons() {
    document.querySelectorAll('#vfoA, #vfoB').forEach(btn => {
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-secondary');
    });
    
    const activeButton = document.getElementById(`vfo${this.currentVFO}`);
    if (activeButton) {
        activeButton.classList.remove('btn-secondary');
        activeButton.classList.add('btn-primary');
    }
}

// 3. Helper function to get the correct VFO command
getVFOCommand() {
    return this.currentVFO === 'B' ? 'FB' : 'FA';
}

















		   updateLocalClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
                
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    timeElement.textContent = timeString + ' (LOCAL)';
                }
                
                setTimeout(() => this.updateLocalClock(), 1000);
            }

            sendTimeToQMX() {
                if (this.timeCommandTimeout) clearTimeout(this.timeCommandTimeout);
                
                this.timeCommandTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const syncedUTC = this.getSyncedTime();
                        const localTime = new Date(syncedUTC.getTime() - (syncedUTC.getTimezoneOffset() * 60000));
                        
                        const hours = localTime.getHours().toString().padStart(2, '0');
                        const minutes = localTime.getMinutes().toString().padStart(2, '0');
                        const seconds = localTime.getSeconds().toString().padStart(2, '0');
                        const timeCommand = `TM${hours}${minutes}${seconds}`;
                        
                        this.sendCommand(timeCommand).then(() => {
                            this.logCAT(`Local time sent to QMX: ${hours}:${minutes}:${seconds}`, 'info');
                        }).catch(e => {
                            console.error("Time command error:", e);
                        });
                    }
                    this.timeCommandTimeout = null;
                }, 100);
            }

            cleanup() {
                if (this.timeSyncInterval) clearInterval(this.timeSyncInterval);
                if (this.clockUpdateInterval) clearInterval(this.clockUpdateInterval);
                if (this.timeCommandTimeout) clearTimeout(this.timeCommandTimeout);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new QMXInterface();
            } catch (error) {
                console.error('Failed to initialize QMX Interface:', error);
            }
        });
    </script>
</body>
</html>
