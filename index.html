<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRP-Labs QDX Commander with Digital Audio by DJ0CU/G4ADF</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
	
	<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
            user-select: none;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .main-panel {
            display: grid;
            grid-template-columns: 1fr 400px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .left-panel, .right-panel, .center-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .panel h3 {
            cursor: grab;
        }

        .panel h3:active {
            cursor: grabbing;
        }

        .sortable-ghost {
            opacity: 0.4;
            background: #ff6b35;
        }

        .sortable-drag {
            opacity: 0.9;
            transform: rotate(2deg);
        }

        .frequency-display.lcd-panel {
            background: #000;
            border-radius: 10px;
            padding: 15px 20px;
            text-align: left;
            border: 2px solid #ff6b35;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .lcd-row {
            font-family: 'Courier New', monospace;
            font-size: 1.8em;
            color: #ff6b35;
            text-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
            letter-spacing: 0.05em;
            white-space: pre;
            line-height: 1.2;
        }

        .tuning-knob-container {
            width: 250px;
            height: 250px;
            position: relative;
            margin: 20px auto;
            display: flex !important;
            justify-content: center;
            align-items: center;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .tuning-knob-container:active {
            cursor: grabbing;
        }

        .tuning-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 2px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.15) 0deg, rgba(0, 0, 0, 0.1) 5deg, rgba(255, 255, 255, 0.15) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 2%, #c0c0c0 4%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 30% 30%, 100% 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 15%, rgba(0, 0, 0, 0.05) 15.5%, transparent 16%);
            z-index: 1;
        }

        .tuning-knob::after {
            content: "";
            position: absolute;
            width: 8px !important;
            height: 100px;
            background-color: #333 !important;
            border-radius: 8px;
            top: 10px;
            z-index: 3;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tuning-knob-center {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tuning-knob:hover::after {
            background-color: #ff6b35 !important;
        }

        .frequency-markings {
            position: absolute;
            width: 280px;
            height: 280px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0;
        }

        .frequency-mark {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            transform-origin: center;
        }

        .frequency-mark.major {
            width: 3px;
            height: 20px;
            background: rgba(255, 107, 53, 0.8);
        }

        .frequency-mark.minor {
            width: 1px;
            height: 10px;
            background: rgba(255, 255, 255, 0.4);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9em;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .btn-secondary:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            color: #fff;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 71, 87, 0.4);
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .mode-btn {
            padding: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            border-color: #ff6b35;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        select {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        select:disabled {
            background: rgba(100, 100, 100, 0.2);
            color: #888;
            border-color: rgba(100, 100, 100, 0.3);
            cursor: not-allowed;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .meter {
            height: 80px;
            background: #111;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .meter-scale {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.8em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }

        .meter-bar {
            height: 20px;
            background: #222;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            border: 1px solid #333;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .meter-indicator {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 30%;
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        #sMeter {
            background: linear-gradient(90deg, 
                #ff6b35 0%,
                #ff6b35 50%, 
                #ffff00 70%,
                #ff9500 85%,
                #ff4757 100%);
        }

        #sMeter::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.9),
                        0 0 15px rgba(255, 107, 53, 0.5);
        }

        #swrMeter {
            background: linear-gradient(90deg, 
                #ff6b35 0%,
                #ff6b35 30%, 
                #ffff00 50%,
                #ff9500 70%,
                #ff4757 100%);
        }

        #swrMeter::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.9),
                        0 0 15px rgba(255, 71, 87, 0.5);
        }

        .meter-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 19.9%,
                rgba(255, 255, 255, 0.1) 20%,
                rgba(255, 255, 255, 0.1) 20.1%
            );
            pointer-events: none;
        }
    
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-text {
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .status-text.connected {
            color: #ff6b35;
            text-shadow: 0 0 8px rgba(255, 107, 53, 0.6);
            text-transform: uppercase;
        }

        .status-text.disconnected {
            color: #ff4757;
            text-shadow: 0 0 8px rgba(255, 71, 87, 0.6);
            text-transform: uppercase;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #ff6b35;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .memory-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .memory-btn {
            padding: 8px 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 45px;
            position: relative;
        }

        .memory-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .memory-btn.memory-occupied {
            background: rgba(255, 107, 53, 0.2);
            border-color: rgba(255, 107, 53, 0.5);
            color: #ff6b35;
        }

        .memory-btn.memory-selected {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            border-color: #ff6b35;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .memory-btn.memory-occupied:hover {
            background: rgba(255, 107, 53, 0.3);
        }

        .memory-btn.memory-store-warning {
            background: rgba(255, 71, 87, 0.2);
            border-color: rgba(255, 71, 87, 0.5);
        }

        .memory-btn.memory-store-warning:hover {
            background: rgba(255, 71, 87, 0.3);
        }

        .memory-edit-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            border: 2px solid #ff6b35;
            border-radius: 15px;
            padding: 25px;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.5);
            min-width: 400px;
            max-width: 500px;
        }

        .memory-edit-modal.active {
            display: block;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
        }

        .modal-overlay.active {
            display: block;
        }

        .memory-edit-modal h3 {
            margin-bottom: 15px;
            color: #ff6b35;
        }

        .memory-edit-modal input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
        }

        .memory-edit-modal .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .memory-label {
            font-size: 0.7em;
            display: block;
            margin-top: 2px;
            color: #ff6b35;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .band-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .band-btn {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: bold;
        }

        .band-btn.active {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            border-color: #ff6b35;
        }

        .band-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        .cat-log {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .cat-log-entry {
            margin-bottom: 2px;
            opacity: 0.8;
        }

        .cat-log-entry.tx {
            color: #ff6b35;
        }

        .cat-log-entry.rx {
            color: #f7931e;
        }

        .cat-log-entry.error {
            color: #ff4757;
        }

        .volume-knob-container {
            width: 80px;
            height: 80px;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .volume-knob-container:active {
            cursor: grabbing;
        }

        .knobs-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 10px;
        }

        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .knob-group label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .knob-level {
            font-family: "Courier New", monospace;
            font-size: 0.9rem;
            text-align: center;
            color: #fff;
            margin-top: 2px;
        }

        .volume-knob-container,
        .volume-knob {
            display: flex !important;
            justify-content: center;
            align-items: center;
            visibility: visible !important;
        }

        .volume-knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
            position: relative;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), inset 0 2px 3px rgba(255, 255, 255, 0.8), inset 0 -2px 3px rgba(0, 0, 0, 0.3);
            transform: rotate(0deg);
            border: 1px solid #888;
            background-image:
                repeating-conic-gradient(rgba(255, 255, 255, 0.1) 0deg, rgba(0, 0, 0, 0.07) 5deg, rgba(255, 255, 255, 0.1) 10deg),
                repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 1%, #c0c0c0 2%),
                linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
            background-size: 100% 100%, 20% 20%, 100% 100%;
        }

        .volume-knob::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e5e5, #c0c0c0);
            background-image:
                repeating-radial-gradient(circle at 50% 50%, transparent 0%, transparent 10%, rgba(0, 0, 0, 0.03) 10.5%, transparent 11%);
            z-index: 1;
        }

        .volume-knob::after {
            content: "";
            position: absolute;
            width: 5px !important;
            height: 38px;
            background-color: #333 !important;
            border-radius: 5px;
            top: 5px;
            z-index: 3;
            transition: background-color 0.2s ease;
        }

        .volume-knob-center {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #888, #666);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 2;
        }

        .volume-knob:hover::after {
            background-color: #ff6b35 !important;
        }

        .volume-knob::before,
        .volume-knob::after,
        .volume-knob-center {
            pointer-events: none;
        }

        .tuning-knob::before,
        .tuning-knob::after,
        .tuning-knob-center {
            pointer-events: none;
        }

        /* Night Mode Toggle Styles */
        .night-mode-toggle-container {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .night-mode-toggle {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .night-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .night-mode-toggle.active {
            background: rgba(255, 107, 53, 0.2);
            border-color: #ff6b35;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.3);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #666, #888);
            border-radius: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }

        .night-mode-toggle.active .toggle-slider {
            left: 32px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
        }

        .toggle-label {
            position: absolute;
            font-size: 0.6em;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
            z-index: 1;
            pointer-events: none;
        }

        .toggle-label.left {
            left: 6px;
        }

        .toggle-label.right {
            right: 6px;
        }

        .night-mode-toggle:not(.active) .toggle-label.left {
            color: #fff;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
        }

        .night-mode-toggle.active .toggle-label.right {
            color: #fff;
            text-shadow: 0 0 3px rgba(255, 107, 53, 0.8);
        }

        /* Audio Processing Panel Styles */
        .audio-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .fft-canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            margin: 10px 0;
        }

        .waterfall-canvas {
            width: 100%;
            height: 200px;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            margin: 10px 0;
        }

        .audio-indicator {
            height: 20px;
            background: #222;
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-level {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            border-radius: 10px;
            transition: width 0.1s ease;
            width: 0%;
        }

        .audio-status {
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #ff6b35;
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .volume-knob-container {
                width: 60px;
                height: 60px;
            }
            .knobs-row {
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>QRP-Labs QDX Commander with Digital Audio by DJ0CU/G4ADF</h1>
            <p>QRP Digital Communications Interface with Real-Time Audio Processing</p>
        </div>

        <div class="main-panel">
            <div class="left-panel">
                <div class="panel" id="serialPanel">
                    <h3>Serial Connection</h3>
                    <div class="control-group">
                        <label>Baud Rate</label>
                        <select id="baudRate">
                            <option value="9600">9600</option>
                            <option value="19200">19200</option>
                            <option value="38400">38400</option>
                            <option value="57600">57600</option>
                            <option value="115200" selected>115200</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button id="connectBtn" class="btn btn-primary">Connect Serial</button>
                    </div>
                </div>

                <div class="panel" id="audioPanel">
                    <h3>Digital Audio</h3>
                    <div class="audio-controls">
                        <button id="startAudioBtn" class="btn btn-primary">Start Audio</button>
                        <button id="stopAudioBtn" class="btn btn-secondary">Stop Audio</button>
                        <button id="testAudioBtn" class="btn btn-secondary" style="grid-column: span 2; margin-top: 10px;">Test Audio System</button>
                    </div>
                    <div class="control-group">
                        <label>Sample Rate</label>
                        <select id="sampleRate">
                            <option value="8000">8 kHz</option>
                            <option value="12000">12 kHz</option>
                            <option value="16000">16 kHz</option>
                            <option value="22050">22.05 kHz</option>
                            <option value="44100">44.1 kHz</option>
                            <option value="48000" selected>48 kHz</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Audio Output</label>
                        <input type="range" id="audioVolumeSlider" class="slider" min="0" max="100" value="50">
                        <span id="audioVolumeLevel">50%</span>
                    </div>
                    <div class="audio-indicator">
                        <div class="audio-level" id="audioLevel"></div>
                    </div>
                    <div class="audio-status" id="audioStatus">Select QDX Audio Device</div>
                </div>

                <div class="panel" id="modePanel">
                    <h3>Operating Mode</h3>
                    <div class="mode-buttons">
                        <div class="mode-btn active" data-mode="USB" data-catmode="2">USB</div>
                        <div class="mode-btn" data-mode="LSB" data-catmode="1">LSB</div>
                    </div>
                </div>

                <div class="panel" id="stepPanel">
                    <h3>Tuning Step</h3>
                    <div class="control-group">
                        <label>Step Size</label>
                        <select id="stepSize">
                            <option value="1">1 Hz</option>
                            <option value="10">10 Hz</option>
                            <option value="100" selected>100 Hz</option>
                            <option value="1000">1 kHz</option>
                            <option value="10000">10 kHz</option>
                        </select>
                    </div>
                </div>

                <div class="panel" id="bandPanel">
                    <h3>Band</h3>
                    <div class="band-buttons">
                        <div class="band-btn" data-band="80">80m</div>
                        <div class="band-btn" data-band="40">40m</div>
                        <div class="band-btn" data-band="30">30m</div>
                        <div class="band-btn active" data-band="20">20m</div>
                        <div class="band-btn" data-band="17">17m</div>
                        <div class="band-btn" data-band="15">15m</div>
                        <div class="band-btn" data-band="12">12m</div>
                        <div class="band-btn" data-band="10">10m</div>
                    </div>
                </div>

                <div class="panel" id="catPanel">
                    <h3>CAT Monitor</h3>
                    <div class="cat-log" id="catLog"></div>
                </div>
            </div>

            <div class="center-panel">
                <div class="panel frequency-display lcd-panel" id="lcdPanel">
                    <div id="lcdRow1" class="lcd-row">QDX Commander...</div>
                    <div id="lcdRow2" class="lcd-row">Connect Radio</div>
                </div>

                <div class="panel" id="tuningPanel">
                    <h3 style="text-align: center; margin-bottom: 15px;">Main Tuning</h3>
                    <div class="tuning-knob-container" id="tuningKnobContainer">
                        <div class="frequency-markings" id="frequencyMarkings"></div>
                        <div class="tuning-knob" id="tuningKnob" tabindex="0" role="slider" aria-label="Frequency Tuning" aria-valuemin="100000" aria-valuemax="999999999" aria-valuenow="14205000">
                            <div class="tuning-knob-center"></div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="spectrumPanel">
                    <h3>Spectrum Display</h3>
                    <canvas class="fft-canvas" id="fftCanvas" width="400" height="150"></canvas>
                    <div class="control-group">
                        <label>FFT Size</label>
                        <select id="fftSize">
                            <option value="256">256</option>
                            <option value="512">512</option>
                            <option value="1024" selected>1024</option>
                            <option value="2048">2048</option>
                        </select>
                    </div>
                </div>

                <div class="panel" id="vfoPanel">
                    <h3>VFO</h3>
                    <div class="controls-grid">
                        <button class="btn btn-primary" id="vfoA">VFO A</button>
                        <button class="btn btn-secondary" id="vfoB">VFO B</button>
                    </div>
                </div>

                <div class="panel" id="transmitPanel">
                    <h3>Transmit</h3>
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="txBtn">TX</button>
                        <button class="btn btn-primary" id="rxBtn">RX</button>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="panel" id="waterfallPanel">
                    <h3>Waterfall Display</h3>
                    <canvas class="waterfall-canvas" id="waterfallCanvas" width="400" height="200"></canvas>
                    <div class="control-group">
                        <label>Speed</label>
                        <input type="range" id="waterfallSpeed" class="slider" min="1" max="10" value="1">
                    </div>
                </div>

                <div class="panel" id="controlsPanel">
                    <h3>Controls</h3>
                    <div class="knobs-row">
                        <div class="knob-group">
                            <label>AF Gain</label>
                            <div class="volume-knob-container">
                                <div class="volume-knob" id="volumeKnob" tabindex="0" role="slider" aria-label="Volume Control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="75">
                                    <div class="volume-knob-center"></div>
                                </div>
                            </div>
                            <div class="knob-level" id="volumeLevel">75%</div>
                        </div>
                        <div class="knob-group">
                            <label>Night Mode</label>
                            <div class="night-mode-toggle-container">
                                <div class="night-mode-toggle active" id="nightModeToggle">
                                    <div class="toggle-slider"></div>
                                    <span class="toggle-label left">OFF</span>
                                    <span class="toggle-label right">ON</span>
                                </div>
                            </div>
                            <div class="knob-level" id="nightModeStatus">ENABLED</div>
                        </div>
                        <div class="knob-group">
                            <label>Signal Gen</label>
                            <div class="volume-knob-container">
                                <div class="volume-knob" id="signalGenKnob" tabindex="0" role="slider" aria-label="Signal Generator" aria-valuemin="0" aria-valuemax="100" aria-valuenow="50">
                                    <div class="volume-knob-center"></div>
                                </div>
                            </div>
                            <div class="knob-level" id="signalGenLevel">1.0kHz</div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="memoryPanel">
                    <h3>Memory</h3>
                    <div class="controls-grid">
                        <button class="btn btn-secondary" id="storeBtn">Store</button>
                        <button class="btn btn-secondary" id="recallBtn">Recall</button>
                        <button class="btn btn-secondary" id="editBtn">Edit</button>
                        <button class="btn btn-secondary" id="clearBtn">Clear</button>
                    </div>
                    <div class="memory-buttons">
                        <div class="memory-btn" data-channel="1">M1</div>
                        <div class="memory-btn" data-channel="2">M2</div>
                        <div class="memory-btn" data-channel="3">M3</div>
                        <div class="memory-btn" data-channel="4">M4</div>
                        <div class="memory-btn" data-channel="5">M5</div>
                        <div class="memory-btn" data-channel="6">M6</div>
                        <div class="memory-btn" data-channel="7">M7</div>
                        <div class="memory-btn" data-channel="8">M8</div>
                        <div class="memory-btn" data-channel="9">M9</div>
                        <div class="memory-btn" data-channel="10">M10</div>
                    </div>
                    <div class="controls-grid" style="margin-top: 10px;">
                        <button class="btn btn-secondary" id="exportBtn">Export</button>
                        <button class="btn btn-secondary" id="importBtn">Import</button>
                        <button class="btn btn-secondary" id="clearAllBtn" style="grid-column: span 2;">Clear All</button>
                    </div>
                    <input type="file" id="importFile" accept=".json" style="display: none;">
                </div>

                <div class="panel" id="sMeterPanel">
                    <h3 style="color: #ff6b35; text-shadow: 0 0 5px rgba(255, 107, 53, 0.5);">Signal Strength</h3>
                    <div class="meter">
                        <div class="meter-scale">
                            <span>S1</span>
                            <span>S3</span>
                            <span>S5</span>
                            <span>S7</span>
                            <span>S9</span>
                            <span style="color: #ff9500;">+20</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-indicator" id="sMeter"></div>
                        </div>
                    </div>
                </div>

                <div class="panel" id="swrPanel">
                    <h3 style="color: #ff9500; text-shadow: 0 0 5px rgba(255, 149, 0, 0.5);">SWR</h3>
                    <div class="meter">
                        <div class="meter-scale">
                            <span style="color: #ff6b35;">1:1</span>
                            <span style="color: #ff6b35;">1.5</span>
                            <span style="color: #ffff00;">2:1</span>
                            <span style="color: #ff9500;">3:1</span>
                            <span style="color: #ff4757;">5:1</span>
                            <span style="color: #ff4757;">∞</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-indicator" id="swrMeter"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span class="status-text disconnected" id="statusText">DISCONNECTED</span>
            </div>
            <div>QDX CAT Interface with Real-Time Audio</div>
            <div id="currentTime"></div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="memory-edit-modal" id="memoryEditModal">
        <h3>Edit Memory Channel <span id="editChannelNumber"></span></h3>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Frequency (MHz)</label>
            <input type="text" id="memoryFreqInput" placeholder="14.205" style="margin-bottom: 5px;">
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Mode</label>
            <select id="memoryModeSelect" style="width: 100%; padding: 10px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px;">
                <option value="USB">USB</option>
                <option value="LSB">LSB</option>
            </select>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Band</label>
            <select id="memoryBandSelect" style="width: 100%; padding: 10px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px;">
                <option value="80">80m</option>
                <option value="40">40m</option>
                <option value="30">30m</option>
                <option value="20">20m</option>
                <option value="17">17m</option>
                <option value="15">15m</option>
                <option value="12">12m</option>
                <option value="10">10m</option>
            </select>
        </div>
        
        <div class="control-group" style="margin-bottom: 15px;">
            <label style="color: #fff; opacity: 0.8;">Label/Description</label>
            <input type="text" id="memoryLabelInput" placeholder="Enter label (e.g., FT8 Frequency)">
        </div>
        
        <div class="btn-group">
            <button class="btn btn-primary" id="saveMemoryEdit">Save</button>
            <button class="btn btn-secondary" id="cancelMemoryEdit">Cancel</button>
        </div>
    </div>

    <script>
        class QDXAudioProcessor {
            constructor(qdxInterface) {
                this.qdxInterface = qdxInterface;
                this.audioContext = null;
                this.analyser = null;
                this.audioBuffer = null;
                this.gainNode = null;
                this.fftSize = 1024;
                this.sampleRate = 48000;
                this.isStreaming = false;
                this.audioVolume = 0.5;
                this.microphone = null;
                this.sourceNode = null;
                
                // Canvas elements
                this.fftCanvas = document.getElementById('fftCanvas');
                this.fftCtx = this.fftCanvas.getContext('2d');
                this.waterfallCanvas = document.getElementById('waterfallCanvas');
                this.waterfallCtx = this.waterfallCanvas.getContext('2d');
                
                // Waterfall display
                this.waterfallHistory = [];
                this.waterfallSpeed = 1; // Much slower default for SSB monitoring
                
                // Audio processing
                this.animationFrame = null;
                this.audioDevices = [];
                this.selectedDeviceId = null;
                
                this.initAudioProcessing();
                this.initEventListeners();
                this.updateAudioButtons(); // Initialize button states
                
                this.qdxInterface.logCAT('QDX Audio Processor ready', 'info');
            }

            async initAudioProcessing() {
                try {
                    // Initialize Web Audio API
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext({ sampleRate: this.sampleRate });
                    
                    // Create analyser node
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = this.fftSize;
                    this.analyser.smoothingTimeConstant = 0.3;
                    this.analyser.minDecibels = -90;
                    this.analyser.maxDecibels = -10;
                    
                    // Create gain node for volume control
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.audioVolume;
                    
                    // Connect analyser to speakers for monitoring
                    this.analyser.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);
                    
                    console.log('Audio processing initialized');
                    this.qdxInterface.logCAT('Web Audio API initialized successfully', 'info');
                    
                    // Load audio devices after a short delay to ensure DOM is ready
                    setTimeout(() => {
                        this.loadAudioDevices();
                    }, 500);
                    
                } catch (error) {
                    console.error('Failed to initialize audio processing:', error);
                    this.qdxInterface.logCAT(`Audio init error: ${error.message}`, 'error');
                }
            }

            async loadAudioDevices() {
                try {
                    this.qdxInterface.logCAT('Loading audio devices...', 'info');
                    this.updateAudioStatus('Loading audio devices...');
                    
                    // Check if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia not supported in this browser');
                    }
                    
                    // First enumerate without permission (limited labels)
                    let devices = await navigator.mediaDevices.enumerateDevices();
                    let audioInputs = devices.filter(device => device.kind === 'audioinput');
                    this.qdxInterface.logCAT(`Found ${audioInputs.length} audio devices (without permission)`, 'info');
                    
                    // Request permission to get device labels
                    try {
                        this.qdxInterface.logCAT('Requesting microphone permission for device labels...', 'info');
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        this.qdxInterface.logCAT('Permission granted! Getting device labels...', 'info');
                        stream.getTracks().forEach(track => track.stop());
                        
                        // Now enumerate with labels
                        devices = await navigator.mediaDevices.enumerateDevices();
                        audioInputs = devices.filter(device => device.kind === 'audioinput');
                        this.qdxInterface.logCAT(`Found ${audioInputs.length} audio devices (with labels)`, 'info');
                        
                    } catch (permError) {
                        this.qdxInterface.logCAT(`Permission denied: ${permError.message}`, 'error');
                        this.qdxInterface.logCAT('Device labels will be limited without microphone permission', 'info');
                    }
                    
                    this.audioDevices = audioInputs;
                    
                    // Log each device
                    audioInputs.forEach((device, index) => {
                        const label = device.label || `Audio Device ${index + 1}`;
                        this.qdxInterface.logCAT(`Device ${index + 1}: ${label} (${device.deviceId.slice(0,8)}...)`, 'info');
                    });
                    
                    this.updateAudioDeviceSelector();
                    this.updateAudioStatus('Audio devices loaded');
                    
                } catch (error) {
                    console.error('Failed to load audio devices:', error);
                    this.qdxInterface.logCAT(`Device enumeration failed: ${error.message}`, 'error');
                    this.updateAudioStatus(`Device loading failed: ${error.message}`);
                }
            }

            updateAudioDeviceSelector() {
                try {
                    this.qdxInterface.logCAT('Creating audio device selector...', 'info');
                    
                    const sampleRateGroup = document.getElementById('sampleRate')?.parentNode;
                    if (!sampleRateGroup) {
                        this.qdxInterface.logCAT('Cannot find sample rate element - DOM not ready', 'error');
                        return;
                    }
                    
                    const audioPanel = sampleRateGroup.parentNode;
                    
                    // Remove existing device selector if it exists
                    const existingGroup = document.getElementById('audioDeviceGroup');
                    if (existingGroup) {
                        existingGroup.remove();
                    }
                    
                    // Create device selector group
                    const deviceGroup = document.createElement('div');
                    deviceGroup.className = 'control-group';
                    deviceGroup.id = 'audioDeviceGroup';
                    
                    const label = document.createElement('label');
                    label.textContent = 'Audio Input Device';
                    deviceGroup.appendChild(label);
                    
                    const deviceSelect = document.createElement('select');
                    deviceSelect.id = 'audioDevice';
                    deviceSelect.style.cssText = `
                        padding: 10px;
                        border: 1px solid rgba(255, 255, 255, 0.3);
                        border-radius: 8px;
                        background: rgba(255, 255, 255, 0.1);
                        color: #fff;
                        font-size: 1em;
                        transition: all 0.3s ease;
                        width: 100%;
                    `;
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = "Use Default Audio Device";
                    deviceSelect.appendChild(defaultOption);
                    
                    // Add device options
                    if (this.audioDevices && this.audioDevices.length > 0) {
                        this.audioDevices.forEach((device, index) => {
                            const option = document.createElement('option');
                            option.value = device.deviceId;
                            option.textContent = device.label || `Audio Device ${index + 1}`;
                            deviceSelect.appendChild(option);
                        });
                        
                        this.qdxInterface.logCAT(`Added ${this.audioDevices.length} devices to selector`, 'info');
                    } else {
                        const noDeviceOption = document.createElement('option');
                        noDeviceOption.value = "";
                        noDeviceOption.textContent = "No audio devices found";
                        deviceSelect.appendChild(noDeviceOption);
                        this.qdxInterface.logCAT('No audio devices available', 'error');
                    }
                    
                    // Add change event listener
                    deviceSelect.addEventListener('change', (e) => {
                        this.selectedDeviceId = e.target.value;
                        const selectedText = e.target.options[e.target.selectedIndex].text;
                        this.qdxInterface.logCAT(`Selected audio device: ${selectedText}`, 'info');
                    });
                    
                    deviceGroup.appendChild(deviceSelect);
                    
                    // Add refresh button
                    const refreshBtn = document.createElement('button');
                    refreshBtn.textContent = 'Refresh Devices';
                    refreshBtn.className = 'btn btn-secondary';
                    refreshBtn.style.cssText = `
                        margin-top: 5px;
                        padding: 5px 10px;
                        font-size: 0.8em;
                    `;
                    refreshBtn.addEventListener('click', () => {
                        this.qdxInterface.logCAT('Manually refreshing audio devices...', 'info');
                        this.loadAudioDevices();
                    });
                    deviceGroup.appendChild(refreshBtn);
                    
                    // Insert before sample rate group
                    audioPanel.insertBefore(deviceGroup, sampleRateGroup);
                    
                    this.qdxInterface.logCAT('Audio device selector created successfully', 'info');
                    
                } catch (error) {
                    console.error('Failed to create device selector:', error);
                    this.qdxInterface.logCAT(`Device selector creation failed: ${error.message}`, 'error');
                }
            }

            initEventListeners() {
                document.getElementById('startAudioBtn').addEventListener('click', () => {
                    this.qdxInterface.logCAT('Start Audio button clicked', 'info');
                    this.startAudioStreaming();
                });
                
                document.getElementById('stopAudioBtn').addEventListener('click', () => {
                    this.qdxInterface.logCAT('Stop Audio button clicked', 'info');
                    this.stopAudioStreaming();
                });
                
                document.getElementById('testAudioBtn').addEventListener('click', () => {
                    this.testAudioSystem();
                });
                
                document.getElementById('sampleRate').addEventListener('change', (e) => {
                    this.sampleRate = parseInt(e.target.value);
                    this.qdxInterface.logCAT(`Sample rate changed to ${this.sampleRate} Hz`, 'info');
                });
                
                document.getElementById('fftSize').addEventListener('change', (e) => {
                    this.fftSize = parseInt(e.target.value);
                    if (this.analyser) {
                        this.analyser.fftSize = this.fftSize;
                    }
                    this.qdxInterface.logCAT(`FFT size changed to ${this.fftSize}`, 'info');
                });
                
                document.getElementById('audioVolumeSlider').addEventListener('input', (e) => {
                    this.audioVolume = e.target.value / 100;
                    document.getElementById('audioVolumeLevel').textContent = `${e.target.value}%`;
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.audioVolume;
                    }
                });
                
                document.getElementById('waterfallSpeed').addEventListener('input', (e) => {
                    this.waterfallSpeed = parseInt(e.target.value);
                });
            }

            async testAudioSystem() {
                try {
                    this.qdxInterface.logCAT('Testing audio system...', 'info');
                    this.updateAudioStatus('Testing Audio System...');
                    
                    // Test if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia not supported in this browser');
                    }
                    
                    // Test basic audio access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.qdxInterface.logCAT('Audio access test: SUCCESS', 'info');
                    
                    // Stop the test stream
                    stream.getTracks().forEach(track => track.stop());
                    
                    // Test audio context
                    if (this.audioContext) {
                        this.qdxInterface.logCAT(`Audio context state: ${this.audioContext.state}`, 'info');
                        this.qdxInterface.logCAT(`Audio context sample rate: ${this.audioContext.sampleRate} Hz`, 'info');
                    }
                    
                    // Test devices
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioInputs = devices.filter(device => device.kind === 'audioinput');
                    this.qdxInterface.logCAT(`Found ${audioInputs.length} audio input devices`, 'info');
                    
                    audioInputs.forEach((device, index) => {
                        this.qdxInterface.logCAT(`Device ${index + 1}: ${device.label || 'Unknown Device'}`, 'info');
                    });
                    
                    this.updateAudioStatus('Audio System Test Complete');
                    this.qdxInterface.logCAT('Audio system test completed successfully!', 'info');
                    
                } catch (error) {
                    this.qdxInterface.logCAT(`Audio system test failed: ${error.message}`, 'error');
                    this.updateAudioStatus(`Audio Test Failed: ${error.message}`);
                }
            }

            async startAudioStreaming() {
                try {
                    this.qdxInterface.logCAT('Attempting to start audio streaming...', 'info');
                    this.updateAudioStatus('Starting Audio...');

                    // Request microphone access with specific device
                    const constraints = {
                        audio: {
                            deviceId: this.selectedDeviceId ? { exact: this.selectedDeviceId } : undefined,
                            sampleRate: this.sampleRate,
                            channelCount: 1,
                            autoGainControl: false,
                            noiseSuppression: false,
                            echoCancellation: false
                        }
                    };

                    this.qdxInterface.logCAT(`Requesting audio access with constraints: ${JSON.stringify(constraints)}`, 'info');
                    this.microphone = await navigator.mediaDevices.getUserMedia(constraints);
                    this.qdxInterface.logCAT('Audio access granted', 'info');
                    
                    // Start audio context if suspended
                    if (this.audioContext.state === 'suspended') {
                        this.qdxInterface.logCAT('Resuming audio context...', 'info');
                        await this.audioContext.resume();
                    }
                    
                    // Create source node from microphone
                    this.sourceNode = this.audioContext.createMediaStreamSource(this.microphone);
                    
                    // Connect source to analyser for FFT processing
                    this.sourceNode.connect(this.analyser);
                    
                    this.isStreaming = true;
                    this.updateAudioStatus('Audio Streaming - Live from QDX');
                    this.updateAudioButtons();
                    
                    // Start audio processing loop
                    this.startAudioProcessingLoop();
                    
                    this.qdxInterface.logCAT('Audio streaming started successfully!', 'info');
                } catch (error) {
                    console.error('Failed to start audio streaming:', error);
                    this.qdxInterface.logCAT(`Audio start error: ${error.message}`, 'error');
                    this.updateAudioStatus(`Audio Error: ${error.message}`);
                    
                    // Provide helpful error messages
                    if (error.name === 'NotAllowedError') {
                        this.qdxInterface.logCAT('Microphone permission denied. Please allow microphone access and try again.', 'error');
                    } else if (error.name === 'NotFoundError') {
                        this.qdxInterface.logCAT('No audio input device found. Check your QDX audio connection.', 'error');
                    } else if (error.name === 'NotReadableError') {
                        this.qdxInterface.logCAT('Audio device is already in use by another application.', 'error');
                    }
                }
            }

            async stopAudioStreaming() {
                try {
                    this.isStreaming = false;
                    
                    // Stop microphone stream
                    if (this.microphone) {
                        this.microphone.getTracks().forEach(track => track.stop());
                        this.microphone = null;
                    }
                    
                    // Disconnect source node
                    if (this.sourceNode) {
                        this.sourceNode.disconnect();
                        this.sourceNode = null;
                    }
                    
                    // Stop animation loop
                    if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                        this.animationFrame = null;
                    }
                    
                    this.updateAudioStatus('Select QDX Audio Device');
                    this.updateAudioButtons();
                    
                    this.qdxInterface.logCAT('Audio streaming stopped', 'info');
                } catch (error) {
                    console.error('Failed to stop audio streaming:', error);
                    this.qdxInterface.logCAT(`Audio stop error: ${error.message}`, 'error');
                }
            }

            startAudioProcessingLoop() {
                if (!this.isStreaming) return;
                
                // Process real audio data from QDX
                this.processRealTimeAudio();
                
                // Update displays
                this.updateSpectrumDisplay();
                this.updateWaterfallDisplay();
                this.updateAudioLevelMeter();
                
                // Continue loop
                this.animationFrame = requestAnimationFrame(() => this.startAudioProcessingLoop());
            }

            processRealTimeAudio() {
                // This now processes real audio data from the selected audio device
                // No simulation needed - we're getting actual audio from QDX via system audio
            }

            updateSpectrumDisplay() {
                if (!this.analyser) return;
                
                const canvas = this.fftCanvas;
                const ctx = this.fftCtx;
                const width = canvas.width;
                const height = canvas.height;
                
                // Get frequency data
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Draw spectrum
                const binWidth = width / freqData.length;
                ctx.fillStyle = '#ff6b35';
                
                for (let i = 0; i < freqData.length; i++) {
                    const barHeight = (freqData[i] / 255) * height;
                    const x = i * binWidth;
                    const y = height - barHeight;
                    
                    // Create gradient for bars
                    const gradient = ctx.createLinearGradient(0, y, 0, height);
                    gradient.addColorStop(0, '#ff6b35');
                    gradient.addColorStop(0.5, '#f7931e');
                    gradient.addColorStop(1, '#ffff00');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, binWidth - 1, barHeight);
                }
                
                // Draw frequency scale
                ctx.fillStyle = '#fff';
                ctx.font = '10px monospace';
                const nyquist = this.sampleRate / 2;
                const step = width / 5;
                
                for (let i = 0; i <= 5; i++) {
                    const freq = (i / 5) * nyquist;
                    const x = i * step;
                    ctx.fillText(`${(freq / 1000).toFixed(1)}k`, x, height - 5);
                }
            }

            updateWaterfallDisplay() {
                if (!this.analyser) return;
                
                const canvas = this.waterfallCanvas;
                const ctx = this.waterfallCtx;
                const width = canvas.width;
                const height = canvas.height;
                
                // Get frequency data
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                
                // Shift existing waterfall data down
                const imageData = ctx.getImageData(0, 0, width, height - this.waterfallSpeed);
                ctx.putImageData(imageData, 0, this.waterfallSpeed);
                
                // Draw new line at top
                const lineData = ctx.createImageData(width, this.waterfallSpeed);
                const data = lineData.data;
                
                for (let x = 0; x < width; x++) {
                    const freqIndex = Math.floor((x / width) * freqData.length);
                    const intensity = freqData[freqIndex];
                    
                    // Create color map (blue -> green -> yellow -> red)
                    let r, g, b;
                    if (intensity < 64) {
                        r = 0;
                        g = 0;
                        b = intensity * 4;
                    } else if (intensity < 128) {
                        r = 0;
                        g = (intensity - 64) * 4;
                        b = 255 - (intensity - 64) * 4;
                    } else if (intensity < 192) {
                        r = (intensity - 128) * 4;
                        g = 255;
                        b = 0;
                    } else {
                        r = 255;
                        g = 255 - (intensity - 192) * 4;
                        b = 0;
                    }
                    
                    for (let y = 0; y < this.waterfallSpeed; y++) {
                        const index = (y * width + x) * 4;
                        data[index] = r;     // Red
                        data[index + 1] = g; // Green
                        data[index + 2] = b; // Blue
                        data[index + 3] = 255; // Alpha
                    }
                }
                
                ctx.putImageData(lineData, 0, 0);
            }

            updateAudioLevelMeter() {
                if (!this.analyser) return;
                
                // Get time domain data for level meter
                const timeData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteTimeDomainData(timeData);
                
                // Calculate RMS level
                let sum = 0;
                for (let i = 0; i < timeData.length; i++) {
                    const sample = (timeData[i] - 128) / 128;
                    sum += sample * sample;
                }
                const rms = Math.sqrt(sum / timeData.length);
                const level = Math.min(100, rms * 100 * 10); // Scale and limit
                
                // Update level meter
                const levelElement = document.getElementById('audioLevel');
                levelElement.style.width = `${level}%`;
            }

            updateAudioStatus(status) {
                document.getElementById('audioStatus').textContent = status;
            }

            updateAudioButtons() {
                const startBtn = document.getElementById('startAudioBtn');
                const stopBtn = document.getElementById('stopAudioBtn');
                
                if (startBtn && stopBtn) {
                    if (this.isStreaming) {
                        startBtn.classList.remove('btn-primary');
                        startBtn.classList.add('btn-secondary');
                        stopBtn.classList.remove('btn-secondary');
                        stopBtn.classList.add('btn-danger');
                    } else {
                        startBtn.classList.remove('btn-secondary');
                        startBtn.classList.add('btn-primary');
                        stopBtn.classList.remove('btn-danger');
                        stopBtn.classList.add('btn-secondary');
                    }
                }
            }

            cleanup() {
                this.stopAudioStreaming();
                if (this.audioContext) {
                    this.audioContext.close();
                }
            }
        }

        class QDXInterface {
            constructor() {
                this.frequency = 14205000;
                this.stepSize = 100;
                this.mode = 'USB';
                this.connected = false;
                this.band = '20';
                this.currentVFO = 'A';
                this.transmitting = false;
                this.pollingInterval = null;
                
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.commandQueue = [];
                this.isProcessingQueue = false;
                this.catTimeout = null;
                this.connectionCheckTimeout = null;
                this.lastCommandTime = 0;
                
                this.memoryChannels = new Array(10).fill(null);
                this.selectedMemoryChannel = null;
                this.memoryMode = 'recall';
                
                this.catLogElement = null;
                
                this.tuningKnobRotation = 0;
                this.tuningLastAngle = 0;
                this.isTuningAdjusting = false;
                this.tuningAnimationFrame = null;
                
                this.totalRotationRange = 270;
                this.minRotation = -135;
                this.maxRotation = 135;
                this.volumeKnobRotation = 0;
                this.volumeLevel = 75;
                this.volumeLastAngle = 0;
                this.isVolumeAdjusting = false;
                this.volumeAnimationFrame = null;
                this.volumeTimeout = null;
                
                this.signalGenKnobRotation = 0;
                this.signalGenLevel = 50;
                this.signalGenLastAngle = 0;
                this.isSignalGenAdjusting = false;
                this.signalGenAnimationFrame = null;
                this.signalGenTimeout = null;

                this.nightModeEnabled = true; // Default to on

                this.lastFrequencies = {
                    '80': 3500000, '40': 7000000, '30': 10100000, '20': 14000000,
                    '17': 18068000, '15': 21000000, '12': 24890000, '10': 28000000
                };
                this.saveFreqTimeout = null;

                try {
                    this.catLogElement = document.getElementById('catLog');
                    
                    this.loadLayout();
                    this.loadLastFrequencies();
                    this.frequency = this.lastFrequencies[this.band];

                    this.initDraggablePanels();
                    this.initTuningKnob();
                    this.initEventListeners();
                    this.initVolumeControl();
                    this.initSignalGenControl();
                    this.initNightModeToggle();
                    this.initMemorySystem();
                    this.updateDisplay();
                    this.updateTXStatus();
                    this.updateConnectionStatus();
                    this.initTimeSync();
                    
                    // Initialize audio processor with proper error handling
                    setTimeout(() => {
                        this.audioProcessor = new QDXAudioProcessor(this);
                        this.logCAT('Audio processor initialized', 'info');
                    }, 1000);
                    
                    window.addEventListener('blur', () => {
                        if (this.isSignalGenAdjusting) this.stopSignalGenAdjust();
                        if (this.isVolumeAdjusting) this.stopVolumeAdjust();
                        if (this.isTuningAdjusting) this.stopTuningAdjust();
                    });
                } catch (error) {
                    console.error('Failed to initialize QDX Interface:', error);
                }
            }

            initMemorySystem() {
                try {
                    const savedMemories = localStorage.getItem('qdxMemoryChannels');
                    if (savedMemories) {
                        this.memoryChannels = JSON.parse(savedMemories);
                    }
                    document.getElementById('storeBtn').addEventListener('click', () => this.setMemoryMode('store'));
                    document.getElementById('recallBtn').addEventListener('click', () => this.setMemoryMode('recall'));
                    document.getElementById('editBtn').addEventListener('click', () => this.setMemoryMode('edit'));
                    document.getElementById('clearBtn').addEventListener('click', () => this.setMemoryMode('clear'));
                    document.getElementById('exportBtn').addEventListener('click', () => this.exportMemories());
                    document.getElementById('importBtn').addEventListener('click', () => {
                        document.getElementById('importFile').click();
                    });
                    document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAllMemories());
                    document.getElementById('importFile').addEventListener('change', (e) => this.importMemories(e));
                    document.querySelectorAll('.memory-btn').forEach((btn) => {
                        const channel = parseInt(btn.dataset.channel);
                        let clickTimer = null;
                        btn.addEventListener('click', (e) => {
                            if (clickTimer) {
                                clearTimeout(clickTimer);
                                clickTimer = null;
                                if (this.memoryMode === 'recall') {
                                    this.storeMemoryChannel(channel);
                                    this.logCAT(`Quick-stored to M${channel}`, 'info');
                                }
                            } else {
                                clickTimer = setTimeout(() => {
                                    clickTimer = null;
                                    this.handleMemoryChannel(channel);
                                }, 250);
                            }
                        });
                        btn.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.editMemoryChannel(channel);
                        });
                    });
                    document.getElementById('saveMemoryEdit').addEventListener('click', () => this.saveMemoryEdit());
                    document.getElementById('cancelMemoryEdit').addEventListener('click', () => this.closeEditModal());
                    document.getElementById('modalOverlay').addEventListener('click', () => this.closeEditModal());
                    this.updateMemoryDisplay();
                    this.setMemoryMode('recall');
                    console.log('Memory system initialized');
                } catch (error) {
                    console.error('Error initializing memory system:', error);
                }
            }

            setMemoryMode(mode) {
                this.memoryMode = mode;
                const buttons = {
                    'store': document.getElementById('storeBtn'),
                    'recall': document.getElementById('recallBtn'),
                    'edit': document.getElementById('editBtn'),
                    'clear': document.getElementById('clearBtn')
                };
                Object.values(buttons).forEach(btn => {
                    btn.classList.remove('btn-primary', 'btn-danger');
                    btn.classList.add('btn-secondary');
                });
                if (buttons[mode]) {
                    buttons[mode].classList.remove('btn-secondary');
                    if (mode === 'clear') {
                        buttons[mode].classList.add('btn-danger');
                    } else {
                        buttons[mode].classList.add('btn-primary');
                    }
                }
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    btn.classList.remove('memory-store-warning');
                    btn.style.cursor = mode === 'recall' ? 'pointer' : 
                                      mode === 'store' ? 'copy' :
                                      mode === 'edit' ? 'text' :
                                      mode === 'clear' ? 'not-allowed' : 'pointer';
                    if (mode === 'store' && this.memoryChannels[index]) {
                        btn.classList.add('memory-store-warning');
                    }
                });
                this.logCAT(`Memory mode: ${mode.toUpperCase()} (${this.getMemoryModeHint(mode)})`, 'info');
            }

            getMemoryModeHint(mode) {
                switch(mode) {
                    case 'recall': return 'Click to recall, double-click to quick-store, right-click to edit';
                    case 'store': return 'Click any memory to store current settings';
                    case 'edit': return 'Click any memory to edit its settings';
                    case 'clear': return 'Click any memory to clear it';
                    default: return '';
                }
            }

            handleMemoryChannel(channel) {
                switch(this.memoryMode) {
                    case 'store': this.storeMemoryChannel(channel); break;
                    case 'recall': this.recallMemoryChannel(channel); break;
                    case 'edit': this.editMemoryChannel(channel); break;
                    case 'clear': this.clearMemoryChannel(channel); break;
                }
            }

            storeMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const existingLabel = this.memoryChannels[channelIndex]?.label || '';
                if (this.memoryChannels[channelIndex]) {
                    const existingMem = this.memoryChannels[channelIndex];
                    const freqMHz = (existingMem.frequency / 1000000).toFixed(3);
                    const label = existingMem.label ? `"${existingMem.label}"` : '';
                    if (!confirm(`Overwrite M${channel}?\n\nCurrent: ${freqMHz} MHz, ${existingMem.mode}${label}\n\nReplace with: ${(this.frequency / 1000000).toFixed(3)} MHz, ${this.mode}?`)) {
                        return;
                    }
                }
                const memoryData = {
                    frequency: this.frequency,
                    mode: this.mode,
                    band: this.band,
                    label: existingLabel,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = channel;
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Stored M${channel}: ${mhz}.${khz}.${hz} Hz, ${this.mode}${existingLabel ? ', "' + existingLabel + '"' : ''}`, 'info');
                setTimeout(() => {
                    this.setMemoryMode('recall');
                }, 1000);
            }

            recallMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                if (!memoryData) {
                    this.logCAT(`Memory M${channel} is empty`, 'error');
                    return;
                }
                this.frequency = memoryData.frequency;
                this.mode = memoryData.mode;
                this.band = memoryData.band;
                this.updateDisplay();
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === this.mode) {
                        btn.classList.add('active');
                    }
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.band === this.band) {
                        btn.classList.add('active');
                    }
                });
                if (this.connected) {
                    const freqStr = this.frequency.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    this.sendCommand(`${vfoCommand}${freqStr}`).then(() => {
                        setTimeout(() => {
                            this.sendCommand(this.getVFOCommand());
                        }, 100);
                    }).catch(e => {
                        this.logCAT(`Failed to set frequency: ${e.message}`, 'error');
                    });
                    
                    const modeBtn = document.querySelector(`[data-mode="${this.mode}"]`);
                    if (modeBtn) {
                        const catMode = modeBtn.dataset.catmode;
                        this.sendCommand(`MD${catMode}`).catch(e => {
                            console.error("Mode command error:", e);
                        });
                    }
                }
                const freqStr = this.frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                const label = memoryData.label ? ` "${memoryData.label}"` : '';
                this.logCAT(`Recalled M${channel}${label}: ${mhz}.${khz}.${hz} Hz, ${this.mode}`, 'info');
                this.selectedMemoryChannel = channel;
                this.updateMemoryDisplay();
            }

            editMemoryChannel(channel) {
                const channelIndex = channel - 1;
                const memoryData = this.memoryChannels[channelIndex];
                this.editingChannel = channel;
                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('memoryEditModal').classList.add('active');
                document.getElementById('editChannelNumber').textContent = channel;
                const freqInput = document.getElementById('memoryFreqInput');
                const modeSelect = document.getElementById('memoryModeSelect');
                const bandSelect = document.getElementById('memoryBandSelect');
                const labelInput = document.getElementById('memoryLabelInput');
                if (memoryData) {
                    freqInput.value = (memoryData.frequency / 1000000).toFixed(6);
                    modeSelect.value = memoryData.mode;
                    bandSelect.value = memoryData.band;
                    labelInput.value = memoryData.label || '';
                } else {
                    freqInput.value = (this.frequency / 1000000).toFixed(6);
                    modeSelect.value = this.mode;
                    bandSelect.value = this.band;
                    labelInput.value = '';
                }
                freqInput.addEventListener('input', () => {
                    const freqMHz = parseFloat(freqInput.value);
                    if (!isNaN(freqMHz)) {
                        const suggestedBand = this.getBandFromFrequency(freqMHz);
                        if (suggestedBand) {
                            bandSelect.value = suggestedBand;
                        }
                    }
                });
                freqInput.focus();
                freqInput.select();
                const handleEnter = (e) => {
                    if (e.key === 'Enter') {
                        this.saveMemoryEdit();
                    } else if (e.key === 'Escape') {
                        this.closeEditModal();
                    }
                };
                freqInput.onkeydown = handleEnter;
                labelInput.onkeydown = handleEnter;
            }

            saveMemoryEdit() {
                if (this.editingChannel === null) return;
                const channelIndex = this.editingChannel - 1;
                const freqInput = document.getElementById('memoryFreqInput').value.trim();
                const mode = document.getElementById('memoryModeSelect').value;
                const band = document.getElementById('memoryBandSelect').value;
                const label = document.getElementById('memoryLabelInput').value.trim();
                let frequency;
                if (freqInput) {
                    const cleanFreq = freqInput.replace(/[^0-9.]/g, '');
                    const freqMHz = parseFloat(cleanFreq);
                    if (isNaN(freqMHz) || freqMHz < 0.1 || freqMHz > 999.999999) {
                        alert('Please enter a valid frequency');
                        document.getElementById('memoryFreqInput').focus();
                        return;
                    }
                    frequency = Math.round(freqMHz * 1000000);
                } else {
                    alert('Please enter a frequency');
                    document.getElementById('memoryFreqInput').focus();
                    return;
                }
                const memoryData = {
                    frequency: frequency,
                    mode: mode,
                    band: band,
                    label: label,
                    timestamp: new Date().toISOString()
                };
                this.memoryChannels[channelIndex] = memoryData;
                localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                this.updateMemoryDisplay();
                this.selectedMemoryChannel = this.editingChannel;
                const freqStr = frequency.toString().padStart(9, '0');
                const mhz = freqStr.substring(0, 3);
                const khz = freqStr.substring(3, 6);
                const hz = freqStr.substring(6, 9);
                this.logCAT(`Updated M${this.editingChannel}: ${mhz}.${khz}.${hz} Hz, ${mode}, ${band}m${label ? ', "' + label + '"' : ''}`, 'info');
                this.closeEditModal();
            }

            closeEditModal() {
                document.getElementById('modalOverlay').classList.remove('active');
                document.getElementById('memoryEditModal').classList.remove('active');
                this.editingChannel = null;
            }

            clearMemoryChannel(channel) {
                const channelIndex = channel - 1;
                if (this.memoryChannels[channelIndex]) {
                    const memData = this.memoryChannels[channelIndex];
                    const freqMHz = (memData.frequency / 1000000).toFixed(3);
                    const label = memData.label || `M${channel}`;
                    if (confirm(`Clear memory channel M${channel}?\n\nFrequency: ${freqMHz} MHz\nMode: ${memData.mode}\nLabel: ${label}`)) {
                        this.memoryChannels[channelIndex] = null;
                        localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                        this.updateMemoryDisplay();
                        this.logCAT(`Cleared memory channel M${channel}`, 'info');
                        if (this.selectedMemoryChannel === channel) {
                            this.selectedMemoryChannel = null;
                        }
                    }
                } else {
                    this.logCAT(`Memory M${channel} is already empty`, 'error');
                }
            }

            clearAllMemories() {
                const usedMemories = this.memoryChannels.filter(m => m !== null).length;
                if (usedMemories === 0) {
                    this.logCAT('No memory channels to clear', 'info');
                    return;
                }
                if (confirm(`Clear ALL memory channels?\n\nThis will delete ${usedMemories} stored memories.\nThis action cannot be undone!`)) {
                    this.memoryChannels = new Array(10).fill(null);
                    localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                    this.selectedMemoryChannel = null;
                    this.updateMemoryDisplay();
                    this.logCAT(`Cleared all ${usedMemories} memory channels`, 'info');
                }
            }

            updateMemoryDisplay() {
                document.querySelectorAll('.memory-btn').forEach((btn, index) => {
                    const channel = index + 1;
                    const memoryData = this.memoryChannels[index];
                    btn.innerHTML = '';
                    btn.classList.remove('memory-occupied', 'memory-selected', 'memory-store-warning');
                    if (memoryData) {
                        btn.classList.add('memory-occupied');
                        if (this.memoryMode === 'store') {
                            btn.classList.add('memory-store-warning');
                        }
                        const channelSpan = document.createElement('span');
                        channelSpan.textContent = `M${channel}`;
                        btn.appendChild(channelSpan);
                        if (memoryData.label) {
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'memory-label';
                            labelSpan.textContent = memoryData.label;
                            btn.appendChild(labelSpan);
                        }
                        btn.title = `M${channel}: ${(memoryData.frequency / 1000000).toFixed(3)} MHz, ${memoryData.mode}${memoryData.label ? ' - ' + memoryData.label : ''}`;
                    } else {
                        btn.textContent = `M${channel}`;
                        btn.title = `M${channel}: Empty`;
                    }
                    if (this.selectedMemoryChannel === channel) {
                        btn.classList.add('memory-selected');
                    }
                });
            }

            exportMemories() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    memories: this.memoryChannels
                };
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `qdx_memories_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.logCAT('Memory channels exported successfully', 'info');
            }

            importMemories(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        if (importData.memories && Array.isArray(importData.memories)) {
                            if (confirm('This will replace all current memory channels. Continue?')) {
                                this.memoryChannels = importData.memories;
                                localStorage.setItem('qdxMemoryChannels', JSON.stringify(this.memoryChannels));
                                this.updateMemoryDisplay();
                                this.logCAT('Memory channels imported successfully', 'info');
                            }
                        } else {
                            throw new Error('Invalid file format');
                        }
                    } catch (error) {
                        this.logCAT(`Import failed: ${error.message}`, 'error');
                        alert('Failed to import memory file.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            logCAT(message, type = 'info') {
                if (!this.catLogElement) {
                    this.catLogElement = document.getElementById('catLog');
                }
                if (!this.catLogElement) return;
                const entry = document.createElement('div');
                entry.className = `cat-log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `${timestamp} ${type.toUpperCase()}: ${message}`;
                this.catLogElement.appendChild(entry);
                this.catLogElement.scrollTop = this.catLogElement.scrollHeight;
                while (this.catLogElement.children.length > 200) {
                    this.catLogElement.removeChild(this.catLogElement.firstChild);
                }
            }

            async initializeRadio() {
                await this.sendCommand('IF');
                await this.sendCommand('FA');
                await this.sendCommand('MD');
                await this.sendCommand('AG');
                await this.sendCommand('ID');
                await this.sendNightModeCommand();
            }

            initEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.disconnectSerial();
                    } else {
                        await this.connectSerial();
                    }
                });
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.mode = btn.dataset.mode;
                        if (this.connected) {
                            const catMode = btn.dataset.catmode;
                            await this.sendCommand(`MD${catMode}`);
                            this.logCAT(`Mode changed to ${this.mode}`, 'info');
                        }
                    });
                });
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.band = btn.dataset.band;
                        this.setBandFrequency(btn.dataset.band);
                    });
                });
                document.getElementById('stepSize').addEventListener('change', (e) => {
                    this.stepSize = parseInt(e.target.value);
                    this.logCAT(`Tuning step set to ${this.stepSize} Hz`, 'info');
                });
                document.getElementById('vfoA').addEventListener('click', async () => {
                    this.selectVFO('A');
                    if (this.connected) {
                        await this.sendCommand('FR0');
                        await this.sendCommand('FT0');
                        await this.sendCommand('FA');
                    }
                });
                document.getElementById('vfoB').addEventListener('click', async () => {
                    this.selectVFO('B');
                    if (this.connected) {
                        await this.sendCommand('FR1');
                        await this.sendCommand('FT1');
                        await this.sendCommand('FB');
                    }
                });
                document.getElementById('txBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('TX');
                        this.transmitting = true;
                        this.updateTXStatus();
                        this.logCAT('Switched to TRANSMIT mode', 'info');
                    } else {
                        this.logCAT('Cannot transmit - radio not connected', 'error');
                    }
                });
                document.getElementById('rxBtn').addEventListener('click', async () => {
                    if (this.connected) {
                        await this.sendCommand('RX');
                        this.transmitting = false;
                        this.updateTXStatus();
                        this.logCAT('Switched to RECEIVE mode', 'info');
                    } else {
                        this.logCAT('Cannot switch to RX - radio not connected', 'error');
                    }
                });
            }

            setBandFrequency(band) {
                if (this.lastFrequencies[band]) {
                    this.frequency = this.lastFrequencies[band];
                    this.updateDisplay();
                    if (this.connected) {
                        this.sendFrequencyImmediate();
                    }
                }
            }

            getBandFromFrequency(freqMHz) {
                if (freqMHz >= 3.500 && freqMHz <= 4.000) return '80';
                if (freqMHz >= 7.000 && freqMHz <= 7.300) return '40';
                if (freqMHz >= 10.100 && freqMHz <= 10.150) return '30';
                if (freqMHz >= 14.000 && freqMHz <= 14.350) return '20';
                if (freqMHz >= 18.068 && freqMHz <= 18.168) return '17';
                if (freqMHz >= 21.000 && freqMHz <= 21.450) return '15';
                if (freqMHz >= 24.890 && freqMHz <= 24.990) return '12';
                if (freqMHz >= 28.000 && freqMHz <= 29.700) return '10';
                return null;
            }
            
            selectVFO(vfo) {
                this.currentVFO = vfo;
                this.updateVFOButtons();
                this.logCAT(`VFO ${vfo} selected`, 'info');
            }

            updateConnectionStatus() {
                const btn = document.getElementById('connectBtn');
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const baudDropdown = document.getElementById('baudRate');
                if (this.connected) {
                    btn.textContent = 'Disconnect';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    statusDot.classList.add('connected');
                    statusText.textContent = 'CONNECTED';
                    statusText.className = 'status-text connected';
                    baudDropdown.disabled = true;
                } else {
                    btn.textContent = 'Connect Serial';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'DISCONNECTED';
                    statusText.className = 'status-text disconnected';
                    baudDropdown.disabled = false;
                }
            }

            updateTXStatus() {
                const txBtn = document.getElementById('txBtn');
                const rxBtn = document.getElementById('rxBtn');
                if (this.transmitting) {
                    txBtn.classList.remove('btn-secondary');
                    txBtn.classList.add('btn-danger');
                    rxBtn.classList.remove('btn-primary');
                    rxBtn.classList.add('btn-secondary');
                } else {
                    txBtn.classList.remove('btn-danger');
                    txBtn.classList.add('btn-secondary');
                    rxBtn.classList.remove('btn-secondary');
                    rxBtn.classList.add('btn-primary');
                }
            }

            updateModeFromCAT(catMode) {
                const modeMap = {
                    '1': 'LSB', '2': 'USB'
                };
                if (modeMap[catMode]) {
                    this.mode = modeMap[catMode];
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.mode === this.mode) {
                            btn.classList.add('active');
                        }
                    });
                } else {
                    this.logCAT(`Unknown mode code received: ${catMode}`, 'error');
                }
            }

            updateSMeter(value) {
                const meter = document.getElementById('sMeter');
                let percentage = value;
                percentage = Math.max(0, Math.min(100, percentage));
                meter.style.width = percentage + '%';
            }

            updateSWRMeter(value) {
                const meter = document.getElementById('swrMeter');
                const swr = value / 100;
                const percentage = Math.min(100, Math.max(0, (swr - 1) / 4 * 100));
                meter.style.width = percentage + '%';
            }

            updateLcdDisplay(row1, row2) {
                const lcdRow1El = document.getElementById('lcdRow1');
                const lcdRow2El = document.getElementById('lcdRow2');
                
                if (lcdRow1El) {
                    lcdRow1El.textContent = row1;
                }
                if (lcdRow2El) {
                    lcdRow2El.textContent = row2;
                }
                
                const detectedVFO = (row1 && row1.charAt(0) === 'B') ? 'B' : 'A';
                
                if (detectedVFO !== this.currentVFO) {
                    this.currentVFO = detectedVFO;
                    this.updateVFOButtons();
                    this.logCAT(`VFO switched to ${this.currentVFO} (auto-detected)`, 'info');
                }
            }

            updateDisplay() {
                this.updateBandFromFrequency();
                const freqMHz = (this.frequency / 1000000).toFixed(6);
                this.updateLcdDisplay(`${this.currentVFO}: ${freqMHz} MHz`, `${this.mode} ${this.band}m`);
            }

            updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('currentTime').textContent = timeString;
                setTimeout(() => this.updateClock(), 1000);
            }

            async initTimeSync() {
                this.updateClock();
            }

            updateBandFromFrequency() {
                const freqMHz = this.frequency / 1000000;
                const detectedBand = this.getBandFromFrequency(freqMHz);
                
                if (detectedBand && detectedBand !== this.band) {
                    this.band = detectedBand;
                    this.updateBandButtons();
                    this.logCAT(`Auto-selected ${this.band}m band for ${freqMHz.toFixed(3)} MHz`, 'info');
                }
            }

            updateBandButtons() {
                document.querySelectorAll('.band-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.band === this.band) {
                        btn.classList.add('active');
                    }
                });
            } 

            updateVFOButtons() {
                document.querySelectorAll('#vfoA, #vfoB').forEach(btn => {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                });
                
                const activeButton = document.getElementById(`vfo${this.currentVFO}`);
                if (activeButton) {
                    activeButton.classList.remove('btn-secondary');
                    activeButton.classList.add('btn-primary');
                }
            }

            getVFOCommand() {
                return this.currentVFO === 'B' ? 'FB' : 'FA';
            }

            loadLastFrequencies() {
                const savedFrequencies = localStorage.getItem('qdxLastFrequencies');
                if (savedFrequencies) {
                    try {
                        const parsedFrequencies = JSON.parse(savedFrequencies);
                        this.lastFrequencies = { ...this.lastFrequencies, ...parsedFrequencies };
                        console.log('Loaded last-used frequencies.');
                    } catch(e) {
                        console.error('Could not parse saved frequencies, using defaults.');
                    }
                }
            }
            
            saveLastFrequency() {
                if (this.saveFreqTimeout) {
                    clearTimeout(this.saveFreqTimeout);
                }
                this.saveFreqTimeout = setTimeout(() => {
                    this.lastFrequencies[this.band] = this.frequency;
                    localStorage.setItem('qdxLastFrequencies', JSON.stringify(this.lastFrequencies));
                }, 1000);
            }
            
            initDraggablePanels() {
                try {
                    const leftPanel = document.querySelector('.left-panel');
                    const centerPanel = document.querySelector('.center-panel');
                    const rightPanel = document.querySelector('.right-panel');

                    const options = {
                        group: 'shared-panels',
                        handle: 'h3',
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        dragClass: 'sortable-drag',
                        onEnd: () => {
                            this.saveLayout();
                        }
                    };

                    Sortable.create(leftPanel, options);
                    Sortable.create(centerPanel, options);
                    Sortable.create(rightPanel, options);
                } catch(e) {
                    console.warn("Could not initialize draggable panels. Is Sortable.js loaded?");
                }
            }

            saveLayout() {
                const layout = {
                    left: [...document.querySelectorAll('.left-panel .panel')].map(p => p.id),
                    center: [...document.querySelectorAll('.center-panel .panel')].map(p => p.id),
                    right: [...document.querySelectorAll('.right-panel .panel')].map(p => p.id)
                };
                localStorage.setItem('qdxPanelLayout', JSON.stringify(layout));
                this.logCAT('Panel layout saved.', 'info');
            }

            loadLayout() {
                const savedLayout = localStorage.getItem('qdxPanelLayout');
                if (savedLayout) {
                    try {
                        const layout = JSON.parse(savedLayout);
                        const columns = {
                            left: document.querySelector('.left-panel'),
                            center: document.querySelector('.center-panel'),
                            right: document.querySelector('.right-panel')
                        };

                        Object.keys(layout).forEach(columnKey => {
                            layout[columnKey].forEach(panelId => {
                                const panelElement = document.getElementById(panelId);
                                if (panelElement && columns[columnKey]) {
                                    columns[columnKey].appendChild(panelElement);
                                }
                            });
                        });
                        console.log('Custom panel layout loaded.');
                    } catch (e) {
                        console.error("Failed to load custom layout, using default.", e);
                        localStorage.removeItem('qdxPanelLayout');
                    }
                }
            }

            initVolumeControl() {
                try {
                    const volumeKnob = document.getElementById('volumeKnob');
                    this.updateVolumeUI();
                    volumeKnob.addEventListener('mousedown', this.startVolumeAdjust.bind(this));
                    volumeKnob.addEventListener('touchstart', this.startVolumeAdjust.bind(this), { passive: false });
                    volumeKnob.addEventListener('wheel', this.handleVolumeWheel.bind(this));
                    volumeKnob.addEventListener('keydown', this.handleVolumeKeyboard.bind(this));
                    console.log('Volume control initialized');
                } catch (error) {
                    console.error('Error initializing volume control:', error);
                }
            }

            startVolumeAdjust(e) {
                e.preventDefault();
                this.isVolumeAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueVolumeAdjust = this.continueVolumeAdjust.bind(this);
                this.boundStopVolumeAdjust = this.stopVolumeAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.volumeLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.addEventListener('mouseup', this.boundStopVolumeAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.volumeLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueVolumeAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopVolumeAdjust);
                }
            }

            continueVolumeAdjust(e) {
                if (!this.isVolumeAdjusting) return;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    const volumeKnob = document.getElementById('volumeKnob');
                    const rect = volumeKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.volumeLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 1.2;
                    deltaAngle *= sensitivity;
                    const newRotation = this.volumeKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.volumeKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    volumeKnob.style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                    const newVolumeLevel = Math.round(((this.volumeKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newVolumeLevel !== this.volumeLevel) {
                        this.volumeLevel = newVolumeLevel;
                        this.updateVolumeUI();
                        this.sendVolumeDynamically();
                    }
                    this.volumeLastAngle = currentAngle;
                    this.volumeAnimationFrame = null;
                });
            }

            stopVolumeAdjust() {
                this.isVolumeAdjusting = false;
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                    this.volumeAnimationFrame = null;
                }
                if (this.boundContinueVolumeAdjust && this.boundStopVolumeAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('mouseup', this.boundStopVolumeAdjust);
                    document.removeEventListener('touchmove', this.boundContinueVolumeAdjust);
                    document.removeEventListener('touchend', this.boundStopVolumeAdjust);
                    this.boundContinueVolumeAdjust = null;
                    this.boundStopVolumeAdjust = null;
                }
                this.sendVolumeCommand();
            }

            handleVolumeKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustVolume(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustVolume(5);
                }
            }

            handleVolumeWheel(e) {
                e.preventDefault();
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                const volumeDelta = steps * 5;
                this.adjustVolume(volumeDelta);
            }

            adjustVolume(delta) {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel + delta));
                if (this.volumeAnimationFrame) {
                    cancelAnimationFrame(this.volumeAnimationFrame);
                }
                this.volumeAnimationFrame = requestAnimationFrame(() => {
                    this.updateVolumeUI();
                    this.sendVolumeCommand();
                    this.volumeAnimationFrame = null;
                });
            }
			
            updateVolumeUI() {
                this.volumeLevel = Math.max(0, Math.min(100, this.volumeLevel));
                this.volumeKnobRotation = this.minRotation + (this.volumeLevel / 100) * this.totalRotationRange;
                document.getElementById('volumeKnob').style.transform = `rotate(${this.volumeKnobRotation}deg)`;
                document.getElementById('volumeLevel').textContent = `${this.volumeLevel}%`;
                document.getElementById('volumeKnob').setAttribute('aria-valuenow', this.volumeLevel);
            }

            sendVolumeDynamically() {
                if (this.volumeTimeout) {
                    clearTimeout(this.volumeTimeout);
                }
                this.volumeTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        this.sendCommand(`AG${this.volumeLevel.toString().padStart(3, '0')}`).catch(e => {
                            console.error("Volume update error:", e);
                        });
                    }
                    this.volumeTimeout = null;
                }, 50);
            }

            async sendVolumeCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    await this.sendCommand(`AG${this.volumeLevel.toString().padStart(3, '0')}`);
                    this.logCAT(`AF Gain set to ${this.volumeLevel}%`, 'info');
                } catch (e) {
                    this.logCAT(`AF Gain command error: ${e.message}`, 'error');
                }
            }

            initSignalGenControl() {
                try {
                    const signalGenKnob = document.getElementById('signalGenKnob');
                    this.signalGenKnobRotation = this.minRotation + (this.signalGenLevel / 100) * this.totalRotationRange;
                    signalGenKnob.style.transform = `rotate(${this.signalGenKnobRotation}deg)`;
                    
                    this.updateSignalGenLevel();
                    
                    signalGenKnob.addEventListener('mousedown', this.startSignalGenAdjust.bind(this));
                    signalGenKnob.addEventListener('touchstart', this.startSignalGenAdjust.bind(this), { passive: false });
                    signalGenKnob.addEventListener('wheel', this.handleSignalGenWheel.bind(this));
                    signalGenKnob.addEventListener('keydown', this.handleSignalGenKeyboard.bind(this));
                    signalGenKnob.setAttribute('aria-valuenow', this.signalGenLevel);
                    
                    console.log('Signal Generator control initialized');
                } catch (error) {
                    console.error('Error initializing Signal Generator control:', error);
                }
            }

            startSignalGenAdjust(e) {
                e.preventDefault();
                this.isSignalGenAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueSignalGenAdjust = this.continueSignalGenAdjust.bind(this);
                this.boundStopSignalGenAdjust = this.stopSignalGenAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.signalGenLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueSignalGenAdjust);
                    document.addEventListener('mouseup', this.boundStopSignalGenAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.signalGenLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueSignalGenAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopSignalGenAdjust);
                }
            }

            continueSignalGenAdjust(e) {
                if (!this.isSignalGenAdjusting) return;
                if (this.signalGenAnimationFrame) {
                    cancelAnimationFrame(this.signalGenAnimationFrame);
                }
                this.signalGenAnimationFrame = requestAnimationFrame(() => {
                    const signalGenKnob = document.getElementById('signalGenKnob');
                    const rect = signalGenKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    let deltaAngle = currentAngle - this.signalGenLastAngle;
                    if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                    if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                    const sensitivity = 0.7;
                    deltaAngle *= sensitivity;
                    const newRotation = this.signalGenKnobRotation + (deltaAngle * 180 / Math.PI);
                    this.signalGenKnobRotation = Math.max(this.minRotation, Math.min(this.maxRotation, newRotation));
                    signalGenKnob.style.transform = `rotate(${this.signalGenKnobRotation}deg)`;
                    const newSignalGenLevel = Math.round(((this.signalGenKnobRotation - this.minRotation) / this.totalRotationRange) * 100);
                    if (newSignalGenLevel !== this.signalGenLevel) {
                        this.signalGenLevel = newSignalGenLevel;
                        this.updateSignalGenLevel();
                        this.sendSignalGenDynamically();
                    }
                    this.signalGenLastAngle = currentAngle;
                    this.signalGenAnimationFrame = null;
                });
            }

            stopSignalGenAdjust() {
                this.isSignalGenAdjusting = false;
                if (this.signalGenAnimationFrame) {
                    cancelAnimationFrame(this.signalGenAnimationFrame);
                    this.signalGenAnimationFrame = null;
                }
                if (this.boundContinueSignalGenAdjust && this.boundStopSignalGenAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueSignalGenAdjust);
                    document.removeEventListener('mouseup', this.boundStopSignalGenAdjust);
                    document.removeEventListener('touchmove', this.boundContinueSignalGenAdjust);
                    document.removeEventListener('touchend', this.boundStopSignalGenAdjust);
                    this.boundContinueSignalGenAdjust = null;
                    this.boundStopSignalGenAdjust = null;
                }
                this.sendSignalGenCommand();
            }

            handleSignalGenKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustSignalGen(-5);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustSignalGen(5);
                }
            }

            handleSignalGenWheel(e) {
                e.preventDefault();
                let steps = e.deltaY > 0 ? -1 : 1;
                const signalGenDelta = steps * 5;
                this.adjustSignalGen(signalGenDelta);
            }

            adjustSignalGen(delta) {
                this.signalGenLevel = Math.max(0, Math.min(100, this.signalGenLevel + delta));
                this.signalGenKnobRotation = this.minRotation + (this.signalGenLevel / 100) * this.totalRotationRange;
                if (this.signalGenAnimationFrame) {
                    cancelAnimationFrame(this.signalGenAnimationFrame);
                }
                this.signalGenAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('signalGenKnob').style.transform = `rotate(${this.signalGenKnobRotation}deg)`;
                    this.updateSignalGenLevel();
                    this.sendSignalGenCommand();
                    this.signalGenAnimationFrame = null;
                });
            }

            updateSignalGenLevel() {
                // Convert percentage to frequency (500Hz to 2000Hz range)
                const frequency = 500 + (this.signalGenLevel / 100) * 1500;
                document.getElementById('signalGenLevel').textContent = `${(frequency/1000).toFixed(1)}kHz`;
                document.getElementById('signalGenKnob').setAttribute('aria-valuenow', this.signalGenLevel);
            }

            sendSignalGenDynamically() {
                if (this.signalGenTimeout) {
                    clearTimeout(this.signalGenTimeout);
                }
                this.signalGenTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const frequency = Math.round(500 + (this.signalGenLevel / 100) * 1500);
                        this.sendCommand(`C2${frequency.toString().padStart(8, '0')}`).catch(e => {
                            console.error("Signal Gen update error:", e);
                        });
                    }
                    this.signalGenTimeout = null;
                }, 50);
            }

            async sendSignalGenCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const frequency = Math.round(500 + (this.signalGenLevel / 100) * 1500);
                    await this.sendCommand(`C2${frequency.toString().padStart(8, '0')}`);
                    this.logCAT(`Signal Generator set to ${(frequency/1000).toFixed(1)}kHz`, 'info');
                } catch (e) {
                    this.logCAT(`Signal Generator command error: ${e.message}`, 'error');
                }
            }

            initNightModeToggle() {
                try {
                    const nightModeToggle = document.getElementById('nightModeToggle');
                    
                    // Set initial state
                    this.updateNightModeUI();
                    
                    // Add click event listener
                    nightModeToggle.addEventListener('click', () => {
                        this.toggleNightMode();
                    });
                    
                    console.log('Night Mode toggle initialized');
                } catch (error) {
                    console.error('Error initializing Night Mode toggle:', error);
                }
            }

            toggleNightMode() {
                this.nightModeEnabled = !this.nightModeEnabled;
                this.updateNightModeUI();
                this.sendNightModeCommand();
            }

            updateNightModeUI() {
                const toggle = document.getElementById('nightModeToggle');
                const status = document.getElementById('nightModeStatus');
                
                if (this.nightModeEnabled) {
                    toggle.classList.add('active');
                    status.textContent = 'ENABLED';
                    status.style.color = '#ff6b35';
                } else {
                    toggle.classList.remove('active');
                    status.textContent = 'DISABLED';
                    status.style.color = '#fff';
                }
            }

            async sendNightModeCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const command = this.nightModeEnabled ? 'QI1' : 'QI0';
                    await this.sendCommand(command);
                    this.logCAT(`Night Mode ${this.nightModeEnabled ? 'enabled' : 'disabled'}`, 'info');
                } catch (e) {
                    this.logCAT(`Night Mode command error: ${e.message}`, 'error');
                }
            }

            initTuningKnob() {
                try {
                    const tuningKnob = document.getElementById('tuningKnob');
                    this.createFrequencyMarkings();
                    this.tuningKnobRotation = 0;
                    tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    
                    tuningKnob.addEventListener('mousedown', this.startTuningAdjust.bind(this));
                    tuningKnob.addEventListener('touchstart', this.startTuningAdjust.bind(this), { passive: false });
                    tuningKnob.addEventListener('wheel', this.handleTuningWheel.bind(this));
                    tuningKnob.addEventListener('keydown', this.handleTuningKeyboard.bind(this));
                    
                    // Add hover keyboard control
                    this.isHoveringTuningKnob = false;
                    this.boundHandleHoverKeyboard = this.handleHoverKeyboard.bind(this);
                    
                    tuningKnob.addEventListener('mouseenter', () => {
                        this.isHoveringTuningKnob = true;
                        tuningKnob.style.boxShadow = '0 0 20px rgba(255, 107, 53, 0.6), 0 12px 24px rgba(0, 0, 0, 0.4)';
                        document.addEventListener('keydown', this.boundHandleHoverKeyboard);
                        this.logCAT('Tuning knob hover: Use arrow keys to tune', 'info');
                    });
                    
                    tuningKnob.addEventListener('mouseleave', () => {
                        this.isHoveringTuningKnob = false;
                        tuningKnob.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3)';
                        document.removeEventListener('keydown', this.boundHandleHoverKeyboard);
                    });
                    
                    tuningKnob.setAttribute('aria-valuenow', this.frequency);
                    console.log('Tuning knob initialized with hover keyboard control');
                } catch (error) {
                    console.error('Error initializing tuning knob:', error);
                }
            }

            handleHoverKeyboard(e) {
                if (!this.isHoveringTuningKnob) return;
                
                // Prevent default behavior for arrow keys
                if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                    e.preventDefault();
                    
                    let freqDelta = 0;
                    const currentStep = this.stepSize;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'ArrowDown':
                            freqDelta = -currentStep;
                            break;
                        case 'ArrowRight':
                        case 'ArrowUp':
                            freqDelta = currentStep;
                            break;
                    }
                    
                    if (freqDelta !== 0) {
                        // Use larger steps if Shift is held
                        if (e.shiftKey) {
                            freqDelta *= 10;
                        }
                        
                        // Use even larger steps if Ctrl is held
                        if (e.ctrlKey) {
                            freqDelta *= 100;
                        }
                        
                        this.updateFrequency(freqDelta);
                        
                        // Update knob rotation
                        const rotationDelta = (freqDelta / currentStep) * 2;
                        this.tuningKnobRotation += rotationDelta;
                        document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                        
                        // Send frequency immediately
                        this.sendFrequencyImmediate();
                        
                        // Show feedback
                        const stepText = e.shiftKey ? `${currentStep * 10} Hz` : 
                                        e.ctrlKey ? `${currentStep * 100} Hz` : 
                                        `${currentStep} Hz`;
                        this.logCAT(`Keyboard tune: ${freqDelta > 0 ? '+' : ''}${freqDelta} Hz (${stepText} step)`, 'info');
                    }
                }
            }

            createFrequencyMarkings() {
                const markingsContainer = document.getElementById('frequencyMarkings');
                markingsContainer.innerHTML = '';
                for (let i = 0; i < 72; i++) {
                    const angle = (i / 72) * 360;
                    const isLarge = i % 6 === 0;
                    const mark = document.createElement('div');
                    mark.className = `frequency-mark ${isLarge ? 'major' : 'minor'}`;
                    mark.style.transform = `rotate(${angle}deg) translate(0, -140px)`;
                    mark.style.left = '50%';
                    mark.style.top = '50%';
                    mark.style.marginLeft = isLarge ? '-1.5px' : '-0.5px';
                    mark.style.marginTop = isLarge ? '-10px' : '-5px';
                    markingsContainer.appendChild(mark);
                }
            }

            startTuningAdjust(e) {
                e.preventDefault();
                this.isTuningAdjusting = true;
                const rect = e.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.boundContinueTuningAdjust = this.continueTuningAdjust.bind(this);
                this.boundStopTuningAdjust = this.stopTuningAdjust.bind(this);
                if (e.type === 'mousedown') {
                    this.tuningLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    document.addEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.addEventListener('mouseup', this.boundStopTuningAdjust);
                } else if (e.type === 'touchstart') {
                    const t = e.touches[0];
                    this.tuningLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
                    document.addEventListener('touchmove', this.boundContinueTuningAdjust, { passive: false });
                    document.addEventListener('touchend', this.boundStopTuningAdjust);
                }
            }

            continueTuningAdjust(e) {
                if (!this.isTuningAdjusting) return;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    const tuningKnob = document.getElementById('tuningKnob');
                    const rect = tuningKnob.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let currentX, currentY;
                    
                    if (e.type === 'mousemove') {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    } else if (e.type === 'touchmove') {
                        e.preventDefault();
                        const t = e.touches[0];
                        currentX = t.clientX;
                        currentY = t.clientY;
                    }
                    
                    const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
                    if (distance < rect.width * 2) {
                        const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                        let deltaAngle = currentAngle - this.tuningLastAngle;
                        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                        
                        const sensitivity = 1.5;
                        deltaAngle *= sensitivity;
                        this.tuningKnobRotation += (deltaAngle * 180 / Math.PI);
                        tuningKnob.style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                        
                        const freqDelta = (deltaAngle * 180 / Math.PI) * this.stepSize * 0.3;
                        
                        if (Math.abs(freqDelta) > 0.1) {
                            this.updateFrequency(freqDelta);
                            this.sendFrequencyImmediate();
                        }
                        this.tuningLastAngle = currentAngle;
                    }
                    this.tuningAnimationFrame = null;
                });
            }

            stopTuningAdjust() {
                this.isTuningAdjusting = false;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                    this.tuningAnimationFrame = null;
                }
                if (this.boundContinueTuningAdjust && this.boundStopTuningAdjust) {
                    document.removeEventListener('mousemove', this.boundContinueTuningAdjust);
                    document.removeEventListener('mouseup', this.boundStopTuningAdjust);
                    document.removeEventListener('touchmove', this.boundContinueTuningAdjust);
                    document.removeEventListener('touchend', this.boundStopTuningAdjust);
                    this.boundContinueTuningAdjust = null;
                    this.boundStopTuningAdjust = null;
                }
                this.sendFrequencyImmediate();
            }

            handleTuningWheel(e) {
                e.preventDefault();
                
                let steps;
                if (Math.abs(e.deltaY) < 50) {
                    steps = e.deltaY > 0 ? -1 : 1;
                } else {
                    steps = e.deltaY > 0 ? -1 : 1;
                }
                
                const freqDelta = steps * this.stepSize;
                
                this.updateFrequency(freqDelta);
                const rotationDelta = steps * 2;
                this.tuningKnobRotation += rotationDelta;
                document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                this.sendFrequencyDynamically();
            }

            handleTuningKeyboard(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.adjustFrequency(-this.stepSize);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.adjustFrequency(this.stepSize);
                }
            }

            adjustFrequency(delta) {
                this.updateFrequency(delta);
                const rotationDelta = (delta / this.stepSize) * 2;
                this.tuningKnobRotation += rotationDelta;
                if (this.tuningAnimationFrame) {
                    cancelAnimationFrame(this.tuningAnimationFrame);
                }
                this.tuningAnimationFrame = requestAnimationFrame(() => {
                    document.getElementById('tuningKnob').style.transform = `rotate(${this.tuningKnobRotation}deg)`;
                    this.sendFrequencyImmediate();
                    this.tuningAnimationFrame = null;
                });
            }

            sendFrequencyImmediate() {
                if (this.connected && this.port && this.writer) {
                    const freqStr = this.frequency.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    this.sendCommand(`${vfoCommand}${freqStr}`).catch(e => {
                        console.error("Frequency update error:", e);
                    });
                }
            }

            sendFrequencyDynamically() {
                if (this.catTimeout) {
                    clearTimeout(this.catTimeout);
                }
                this.catTimeout = setTimeout(() => {
                    if (this.connected && this.port && this.writer) {
                        const freqStr = this.frequency.toString().padStart(11, '0');
                        const vfoCommand = this.getVFOCommand();
                        this.sendCommand(`${vfoCommand}${freqStr}`).catch(e => {
                            console.error("Frequency update error:", e);
                        });
                    }
                    this.catTimeout = null;
                }, 5);
            }
			
            startPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                this.pollingInterval = setInterval(async () => {
                    if (this.connected) {
                        await this.sendCommand('IF');
                        await this.sendCommand('AG');
                        await this.sendCommand('QI');
                    }
                }, 500);
            }

            stopPolling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                }
            }

            parseIfResponse(data) {
                try {
                    const freq = parseInt(data.substring(0, 11));
                    if (!isNaN(freq) && freq > 0 && freq !== this.frequency && !this.isTuningAdjusting) {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                    const txStatus = data.substring(26, 27);
                    const isTransmitting = (txStatus === '1');
                    if (isTransmitting !== this.transmitting) {
                        this.transmitting = isTransmitting;
                        this.updateTXStatus();
                    }
                    const catMode = data.substring(27, 28);
                    this.updateModeFromCAT(catMode);
                } catch (error) {
                    this.logCAT(`Error parsing IF response: ${error.message}`, 'error');
                }
            }

            async sendFrequencyCommand() {
                if (!this.connected || !this.port || !this.writer) return;
                try {
                    const freqStr = this.frequency.toString().padStart(11, '0');
                    const vfoCommand = this.getVFOCommand();
                    await this.sendCommand(`${vfoCommand}${freqStr}`);
                    document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    const displayStr = this.frequency.toString().padStart(9, '0');
                    const mhz = displayStr.substring(0, 3);
                    const khz = displayStr.substring(3, 6); 
                    const hz = displayStr.substring(6, 9);
                    this.logCAT(`VFO ${this.currentVFO} frequency set to ${mhz}.${khz}.${hz} Hz`, 'info');
                } catch (e) {
                    this.logCAT(`Frequency command error: ${e.message}`, 'error');
                }
            }

            async updateFrequency(delta) {
                this.frequency += delta;
                this.frequency = Math.max(100000, Math.min(999999999, this.frequency));
                this.frequency = Math.round(this.frequency);
                this.updateDisplay();
                this.saveLastFrequency();
            }

            async connectSerial() {
                try {
                    if (!navigator.serial) {
                        this.logCAT('WebSerial API not supported', 'error');
                        return false;
                    }

                    const selectedBaud = parseInt(document.getElementById('baudRate').value);
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ 
                        baudRate: selectedBaud,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    
                    this.connected = true;
                    this.lastCommandTime = Date.now();
                    this.updateConnectionStatus();
                    this.logCAT(`Serial connected at ${selectedBaud} baud`, 'rx');
                    
                    this.startReading();
                    this.startConnectionHealthCheck();
                    await this.initializeRadio();
                    this.startPolling();
                    return true;
                } catch (error) {
                    this.logCAT(`Connection failed: ${error.message}`, 'error');
                    this.connected = false;
                    this.updateConnectionStatus();
                    return false;
                }
            }

            async disconnectSerial() {
                try {
                    this.connected = false;
                    
                    // Stop audio streaming if active
                    if (this.audioProcessor && this.audioProcessor.isStreaming) {
                        await this.audioProcessor.stopAudioStreaming();
                    }
                    
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.stopPolling();
                    if (this.reader) {
                        try {
                            await this.reader.cancel();
                        } catch (e) {
                            console.log('Reader cancel error:', e);
                        }
                        try {
                            await this.reader.releaseLock();
                        } catch (e) {
                            console.log('Reader release error:', e);
                        }
                        this.reader = null;
                    }
                    if (this.writer) {
                        try {
                            await this.writer.releaseLock();
                        } catch (e) {
                            console.log('Writer release error:', e);
                        }
                        this.writer = null;
                    }
                    if (this.port) {
                        try {
                            await this.port.close();
                        } catch (e) {
                            console.log('Port close error:', e);
                        }
                        this.port = null;
                    }
                    this.logCAT('Serial disconnected', 'rx');
                } catch (error) {
                    this.connected = false;
                    this.reader = null;
                    this.writer = null;
                    this.port = null;
                    if (this.connectionCheckTimeout) {
                        clearTimeout(this.connectionCheckTimeout);
                        this.connectionCheckTimeout = null;
                    }
                    this.updateConnectionStatus();
                    this.logCAT(`Disconnect error: ${error.message}`, 'rx');
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.connected && this.reader) {
                        try {
                            const { value, done } = await this.reader.read();
                            if (done) {
                                this.logCAT('Hardware disconnected', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            }
                            const text = new TextDecoder().decode(value);
                            buffer += text;
                            this.lastCommandTime = Date.now();
                            while (buffer.includes(';')) {
                                const end = buffer.indexOf(';');
                                const response = buffer.substring(0, end);
                                buffer = buffer.substring(end + 1);
                                if (response.trim()) {
                                    this.processResponse(response.trim());
                                }
                            }
                        } catch (readError) {
                            if (readError.name === 'NetworkError' || 
                                readError.message.includes('device has been lost') ||
                                readError.message.includes('The port is not open') ||
                                readError.code === 19) {
                                this.logCAT('Hardware disconnected during read', 'error');
                                this.handleHardwareDisconnect();
                                break;
                            } else {
                                this.logCAT(`Read error: ${readError.message}`, 'error');
                            }
                        }
                    }
                } catch (error) {
                    this.logCAT(`Reader stream error: ${error.message}`, 'error');
                    if (this.connected) {
                        this.handleHardwareDisconnect();
                    }
                }
            }

            async sendCommand(command) {
                if (!this.connected || !this.writer) {
                    return null;
                }
                try {
                    const fullCommand = command + ';';
                    const data = new TextEncoder().encode(fullCommand);
                    await this.writer.write(data);
                    this.logCAT(command, 'tx');
                    this.lastCommandTime = Date.now();
                    return true;
                } catch (error) {
                    if (error.name === 'NetworkError' || 
                        error.message.includes('device has been lost') ||
                        error.message.includes('The port is not open') ||
                        error.code === 19) {
                        this.logCAT('Hardware disconnected during command', 'error');
                        this.handleHardwareDisconnect();
                    } else {
                        this.logCAT(`Send error: ${error.message}`, 'error');
                    }
                    return false;
                }
            }

            handleHardwareDisconnect() {
                if (!this.connected) return;
                this.connected = false;
                this.reader = null;
                this.writer = null;
                this.port = null;
                if (this.connectionCheckTimeout) {
                    clearTimeout(this.connectionCheckTimeout);
                    this.connectionCheckTimeout = null;
                }
                this.updateConnectionStatus();
                this.logCAT('Auto-disconnect complete', 'rx');
            }

            startConnectionHealthCheck() {
                if (!this.connected) return;
                const now = Date.now();
                const timeSinceLastCommand = now - this.lastCommandTime;
                if (timeSinceLastCommand > 10000 && this.connected) {
                    this.sendCommand('ID').catch(() => {
                        this.logCAT('Connection health check failed', 'error');
                        this.handleHardwareDisconnect();
                    });
                }
                this.connectionCheckTimeout = setTimeout(() => {
                    this.startConnectionHealthCheck();
                }, 5000);
            }

            processResponse(response) {
                this.logCAT(response, 'rx');
                if (response.startsWith('IF')) {
                    this.parseIfResponse(response.substring(2));
                } else if (response.startsWith('AG')) {
                    const gain = parseInt(response.substring(2));
                    if (!isNaN(gain) && !this.isVolumeAdjusting) {
                        this.volumeLevel = gain;
                        this.updateVolumeUI();
                    }
                } else if (response.startsWith('FA')) {
                    const freq = parseInt(response.substring(2));
                    if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'A') {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                } else if (response.startsWith('FB')) {
                    const freq = parseInt(response.substring(2));
                    if (!isNaN(freq) && freq > 0 && !this.isTuningAdjusting && this.currentVFO === 'B') {
                        this.frequency = freq;
                        this.updateDisplay();
                        document.getElementById('tuningKnob').setAttribute('aria-valuenow', this.frequency);
                    }
                } else if (response.startsWith('MD')) {
                    const mode = response.substring(2);
                    this.updateModeFromCAT(mode);
                } else if (response.startsWith('TX')) {
                    this.transmitting = true;
                    this.updateTXStatus();
                } else if (response.startsWith('RX')) {
                    this.transmitting = false;
                    this.updateTXStatus();
                } else if (response.startsWith('ID')) {
                    this.logCAT(`Radio ID: ${response.substring(2)}`, 'info');
                } else if (response.startsWith('C2')) {
                    const freq = parseInt(response.substring(2));
                    if (!isNaN(freq) && !this.isSignalGenAdjusting) {
                        const percentage = ((freq - 500) / 1500) * 100;
                        this.signalGenLevel = Math.max(0, Math.min(100, percentage));
                        this.updateSignalGenLevel();
                    }
                } else if (response.startsWith('QI')) {
                    const nightMode = response.substring(2);
                    if (nightMode === '1' || nightMode === '0') {
                        this.nightModeEnabled = (nightMode === '1');
                        this.updateNightModeUI();
                    }
                }
            }

            cleanup() {
                if (this.pollingInterval) clearInterval(this.pollingInterval);
                if (this.connectionCheckTimeout) clearTimeout(this.connectionCheckTimeout);
                if (this.audioProcessor) {
                    this.audioProcessor.cleanup();
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new QDXInterface();
            } catch (error) {
                console.error('Failed to initialize QDX Interface:', error);
            }
        });
    </script>
</body>
</html>
